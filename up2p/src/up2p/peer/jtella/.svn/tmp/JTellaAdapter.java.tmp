package up2p.peer.jtella;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringWriter;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import protocol.com.kenmccrary.jtella.ConnectionData;
import protocol.com.kenmccrary.jtella.GNUTellaConnection;
import protocol.com.kenmccrary.jtella.GUID;
import protocol.com.kenmccrary.jtella.Host;
import protocol.com.kenmccrary.jtella.HostCache;
import protocol.com.kenmccrary.jtella.MessageReceiver;
import protocol.com.kenmccrary.jtella.NodeConnection;
import protocol.com.kenmccrary.jtella.PushMessage;
import protocol.com.kenmccrary.jtella.SearchMessage;
import protocol.com.kenmccrary.jtella.SearchReplyMessage;
import protocol.com.kenmccrary.jtella.SearchSession;
import protocol.com.kenmccrary.jtella.SubNetGNUTellaConnection;
import protocol.com.kenmccrary.jtella.SubNetRouter;
import up2p.core.BasePeerNetworkAdapter;
import up2p.core.LocationEntry;
import up2p.core.NetworkAdapterException;
import up2p.core.ResourceNotFoundException;
import up2p.core.WebAdapter;
import up2p.repository.ResourceEntry;
import up2p.repository.ResourceList;
import up2p.search.SearchQuery;
import up2p.search.SearchResponse;
import up2p.search.SearchResponseListener;
import up2p.servlet.HttpParams;
import up2p.xml.TransformerHelper;

/**
 * Implements a Network Adapter using a Gnutella peer-to-peer protocol.
 * 
 * @author Michael Yartsev (anijap@gmail.com)
 * @author alan
 * @author Alexander Craig
 * @version 1.2
 */

public class JTellaAdapter extends BasePeerNetworkAdapter implements MessageReceiver, SearchResponseListener {
    /** Location of local file containing cache of Gnutella hosts. */
    //public static final String HOST_CACHE_FILE = "up2p.peer.jtella.hostCache";
	public static final String HOST_CACHE_FILE = "data/HostCache.xml";
	
	/** The number of milliseconds that search sessions should remain active for */
	public static final int SEARCH_TIMEOUT_MILLIS = 60000;

    /** Local port where Gnutella listens for incoming connections. */
    public static final String DEFAULT_LOCAL_PORT = "6346";

    /** Name of Logger used by this adapter. */
    public static final String LOGGER = "up2p.peer.jtella";

    /** Logger used by this adapter. */
    private static Logger LOG = Logger.getLogger(LOGGER);

    /** Location of property file for Log4J configuration for this adapter. */
    public static final String LOG_PROPERTY_FILE = "up2p.peer.jtella.log4j.properties";
    
    /**
     * GNUTellaConnection object (of the JTella library) that implements the Gnutella protocol
     */
    private static GNUTellaConnection c;
    
    /** 
     * Stores the messages from the network indexed by their query Id.
     * This way, once the answer comes from the system, we can find the original query message.
     * Note: Multiple requests can be associated with the same query id. In this case, all messages
     * must have the same originating connection or they will be discarded. Only the most recently
     * received request is stored in the messageTable.
     **/
    private static Map<String, SearchMessage> messageTable;
    
    /**
     * A map of cached lists or resource id's which are to be serialized in to search
     * response messages to provide metric data to quering nodes. Only one resource
     * list is cached per community. The map is indexed by community id:
     * 
     * ie. Map<Community id, List<Resource Ids>>
     */
    private static Map<String, List<String>> metricCache;
    
    /**
     * A map of peer ID's (IP address and port) and client identifiers
     * (Gnutella GUIDs). This is updated every time a search reply message is received,
     * and the mapping is used to generate PUSH messages when a direct file
     * transfers fails.
     * 
     * Map < peer ID (IP/Port) , Client Identifier (GUID) >
     */
    private static Map<String, GUID> peerIdToClientGuid;
    
    /** 
     * A singleton instance of HostCacheParser used to manage the static
     * host cache. This should always be accessed through the singleton
     * accessor "getHostCacheParser()"
     */
    private static HostCacheParser hostCacheParser;
    
    private static List<Thread> openSearchSessions;

    /**
     * Initialize logging.
     */
    static {
        Properties logProps = new Properties();
        InputStream inStream = JTellaAdapter.class.getResourceAsStream(LOG_PROPERTY_FILE);
        if (inStream != null) {
            try {
                logProps.load(inStream);
                PropertyConfigurator.configure(logProps);
            } 
            catch (IOException e) {
                System.err.println("Error reading Log4J configuration for JTellaAdapter.");
            }
        } 
        else {
        	System.err.println("Error getting Log4J configuration file for JTellaAdapter.");        	
        }
    }
    
    /**
     * Creates a JTella Adapter
     * @param incomingPort	The port to listen for Gnutella connections on.
     * 						Uses the default value if null is passed.
     */
    private JTellaAdapter(String incomingPort) {
    	initialize(incomingPort);
    	initializeHostCache();
    	messageTable = new HashMap<String,SearchMessage>();
    	metricCache = new HashMap<String, List<String>>();
    	peerIdToClientGuid = new HashMap<String,GUID>();
    	openSearchSessions = new ArrayList<Thread>();
    	LOG.info("JTella adapter initialized.");
    }
    
    
    /**
     * http://en.wikipedia.org/wiki/Singleton_pattern
     * 
     * Singleton pattern used with the JTellaAdapter, so that there's only one instance
     * of the adapter running at any given time.
     */
    private static class SingletonHolder {
    	private static String incomingPort = null;
    	private static JTellaAdapter INSTANCE = null;
    }
    
    /**
     * Returns a singleton instance of the JTella adapter
     * @return a singleton instance of the JTella adapter
     */
    public static JTellaAdapter getInstance() {
    	if(SingletonHolder.INSTANCE == null) {
    		SingletonHolder.INSTANCE = new JTellaAdapter(SingletonHolder.incomingPort);
    	}
    	return SingletonHolder.INSTANCE;
    }
    
    /**
     * Sets the incoming port to use for the Gnutella connection. Note
     * that this has no effect if called after the connection is
     * initiated.
     * @param incomingPort	The port to listen for Gnutella connections on
     */
    public static void setGnutellaPort(String incomingPort) {
    	SingletonHolder.incomingPort = incomingPort;
    }
    
    /*
     * @see up2p.core.NetworkAdapter#setProperty(java.lang.String,
     * java.lang.String)
     */
    public void setProperty(String propertyName, String propertyValue) {
        LOG.info("setProperty method was called in JTellaAdapter.");
        
    }
    
    /**
     * Initializes the adapter
     * @param incomingPort	The port to listen for Gnutella connections on.
     * 						Uses the default value if null is passed.
     */
    private void initialize(String incomingPort) {
		try {
			ConnectionData connData = new ConnectionData();
			connData.setIncommingConnectionCount(10);
			connData.setOutgoingConnectionCount(10);
			connData.setUltrapeer(true);
			connData.setIncomingPort(Integer.valueOf(DEFAULT_LOCAL_PORT).intValue());
			connData.setAgentHeader("up2p");
			
			// Note: The incoming port assignment here explicitly replaces the default value
			// ("6346") used in ConnectionData, and changing the constant in ConnectionData
			// will have no effect on U-P2P. To change the incoming port, change the value of
			// "up2p.gnutella.incoming" in webAdapter.properties (located at
			// "up2p\WEB-INF\classes\\up2p\core")
			if(incomingPort == null) {
				incomingPort = DEFAULT_LOCAL_PORT;
			}
			try {
				connData.setIncomingPort(Integer.parseInt(incomingPort));
			} catch (NumberFormatException e) {
				LOG.error("Invalid Gnutella port specified (\"" + incomingPort + "\"), using default.");
				incomingPort = DEFAULT_LOCAL_PORT;
				connData.setIncomingPort(Integer.parseInt(incomingPort));
			}
			LOG.info("Listening for incoming connections on port: " + incomingPort);
			System.out.println("Incoming Gnutella port: " + incomingPort);
			
			c = new GNUTellaConnection(connData);
			c.getSearchMonitorSession(this);
			c.createFileServerSession(this);
			
			LOG.info("JTellaAdapter:: init: about to start the GnutellaConnection" );
			c.start();
			LOG.info("JTellaAdapter:: init: GnutellaConnection started" );
		} 
		catch(NumberFormatException e) {
			LOG.debug("NumberFormatException while initializing JTella adapter: " + e.getMessage());	
		}
    	catch (UnknownHostException e) {
			LOG.error("UnknownHostException while initializing JTellaAdapter: " + e.getMessage());
		} 
		catch (IOException e) {
			LOG.error("IOException while initializing JTellaAdapter: " + e.getMessage());
		}
    }
    
    /**
     * Initializes the Host Cache
     */
    private void initializeHostCache() {
    	LOG.info("== Initializing Host Cache ==");
    	
    	//Get hosts from the HostCache
    	HostCacheParser hostCacheParser = getHostCacheParser();
    	Host[] hosts = hostCacheParser.getHosts();
    	
		//Connect to these hosts (if any)
		if(hosts != null) {
    		HostCache hostCache =  c.getHostCache();
    		for(int i=0; i < hosts.length; i++) {
    			Host thehost= new Host(hosts[i].getIPAddress(), hosts[i].getPort(), 1, 1);
    			hostCache.addHost(thehost);//hosts[i].getIP(), hosts[i].getPort());
    		}
		}
		
    	LOG.info("== Finished initializing Host Cache ==");
    }
    
    /**
     * @return	The singleton instance of HostCacheParser used to manage the
     * 			JTellaAdapter's host cache.
     */
    public static HostCacheParser getHostCacheParser() {
    	if(hostCacheParser == null) {
    		hostCacheParser = new HostCacheParser(System.getProperty(WebAdapter.UP2P_HOME) 
        			+ File.separator + HOST_CACHE_FILE);
    	}
    	
    	if(hostCacheParser.getDynamicHostCache() == null &&
    			c != null) {
    		hostCacheParser.setDynamicHostCache(c.getHostCache());
    	}
    	
    	return hostCacheParser;
    }
    
	public boolean isAsynchronous() {
		return true;
	}
	
	/**
	 * Updates the metric resourcee id list cache for a specific community. If a list of
	 * resource id's already exists the list is replaced by the newly provided list.
	 * 
	 * @param communityId	The community id to update the cache contents for
	 * @param localResIds	The list of resource id's to cache for the specified community
	 */
	public void updateMetricCache(String communityId, List<String> localResIds) {
		if(metricCache.containsKey(communityId)) {
			metricCache.remove(communityId);
		}
		metricCache.put(communityId, localResIds);
	}

    /**
     * Performs a search on the GNutella network and returns the results
     * TODO: deprecated: I just leave it to avoid having to clean up properly; tbd: remove and clean up
     */
	public SearchResponse[] searchNetwork(String communityId, SearchQuery query, long maxTimeout) 
		throws NetworkAdapterException {
        return null;
	}

	/**
     * Performs a search on the GNutella network and returns the results
     */
	public void searchNetwork(String communityId, String query, String queryId) {
		LOG.info("User requesting to search the network. Query:: " + query);
		
		// Just to make sure that we're not outputting a new search that's from the network 
		if (messageTable.containsKey(queryId)){
			LOG.error("JTELLA Adapter error: outputting a search that was already from the network! [caught]");
			return;
		}
		
		// Form the search request using provided query id
        SearchRequestMessage request = new SearchRequestMessage(queryId, communityId, query);
        
        // -Do the search-
		StringWriter sw = new StringWriter();
		Node requestXML = request.serialize(); //Serializing the node
        try {
			TransformerHelper.encodedTransform((Element) requestXML, "UTF-8", sw, true); //Applying the transformation
		} 
        catch (IOException e) {
			System.out.println("Failed sending up2p request.");
			e.printStackTrace();
		}
        
        final String searchCriteria = sw.toString().trim();
        final String subNetId = communityId;
        
        // Create a new thread to generate and terminate the search session after a specified timeout
        Thread searchSession = new Thread(new Runnable() {
			@Override
			public void run() {
				SearchSession search = null;
		        if(c instanceof SubNetGNUTellaConnection) {
		        	search = ((SubNetGNUTellaConnection)c).createSubNetSearchSession(searchCriteria, 0, subNetId, 10, 0, JTellaAdapter.this);
		        } else {
		        	search = c.createSearchSession(searchCriteria, 0, 10, 0, JTellaAdapter.this);
		        }
		        LOG.debug("Search initiated: Hash - " + search.hashCode());
				
				try {
					Thread.sleep(SEARCH_TIMEOUT_MILLIS);
				} catch (InterruptedException e) {
					LOG.error("Search session timeout thread interrupted, search session closing prematurely.");
				}
				LOG.debug("Search closed: Hash - " + search.hashCode());
				search.close();
				
				synchronized(openSearchSessions) {
		        	openSearchSessions.remove(this);
		        }
			}
        });
        
        synchronized(openSearchSessions) {
        	openSearchSessions.add(searchSession);
        }
        searchSession.start();
        
		LOG.info("JTellaAdapter:exiting search method");        
	}

	public void shutdown() {
		//TODO - is there anything else to the shutdown sequence?
		LOG.info("Stopping Gnutella connection");
		synchronized(openSearchSessions) {
			for(Thread session : openSearchSessions) {
				session.interrupt();
			}
        }
		c.stop();
	}

	/**
	 * Handles incoming search requests from the network.
	 * 
	 * New: Multiple requests with the same query id are now serviced if the query
	 * is deemed valid (see below), and all tuples are collected as part of a single result set.
	 * 
	 * A never before seen query id is automatically considered to be valid. If the query.
	 * id has already been serviced than the new request must have the same originating connection, and
	 * must have different search criteria than the last request serviced.
	 */
	public void receiveSearch(SearchMessage message) {
		LOG.info("Received a search message");
		
		// Parse u-p2p message
		String xmlMessage = message.getSearchCriteria().trim();
		
		try {
			
			// Parse the XML into a SearchRequestMessage
			DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
			Document document = db.parse(new ByteArrayInputStream(xmlMessage.getBytes("UTF-8")));
			SearchRequestMessage searchMessage = SearchRequestMessage.parse(document.getDocumentElement());
			
			
			// Check to ensure the request is valid
			// TODO: The criteria should probably be checked against all messages with the same query id instead
			//             of just the most recent	
			boolean validQuery = false;
			
			if (!messageTable.containsKey(searchMessage.getId())) {
				
				// The message has a new query id, automatically valid
				LOG.info("New unique query id: "+ searchMessage.getId()+" received, processing request." );
				messageTable.put(searchMessage.getId(), message);
				validQuery = true;
				
			} else {
				
				// Query id has been seen before, need to further check validity
				SearchMessage lastMessage = messageTable.get(searchMessage.getId());
				
				if(lastMessage.getOriginatingConnection() == message.getOriginatingConnection() &&
						!lastMessage.getSearchCriteria().trim().equals(xmlMessage)) {
					
					// Message has the same originating connection and new criteria, handle it
					LOG.info("New search criteria for query id: "+ searchMessage.getId()+" received, processing request." );
					messageTable.remove(searchMessage.getId());
					messageTable.put(searchMessage.getId(), message);
					validQuery = true;
					
				} else {
		
					// Message criteria is identical to the previous request, ignore it
					LOG.info("Query id: "+ searchMessage.getId()+" received duplicate search criteria, ignoring request." );
					
				}
			}
			
			if (validQuery) {
				// Send query to Core2Network adapter
				LOG.info("Launching search with criteria:\n\t" + xmlMessage);
				adapter.searchLocal(searchMessage.getCommunityId(), searchMessage.getQuery(), this, searchMessage.getId());
			}else {
				// Otherwise just ignore the query, we've already had it (the exact same query id and search criteria)
				LOG.info("Ignoring search message with id: "+ searchMessage.getId());
			}
		}
		catch (Exception e)
		{}
			
			
	}

	/**
	 *  implementation of ReceiveSearchReply in the JTella interface: receives responses from the network [QUERYHIT messages].
	 *  The message is parsed and the contents sent to the tuplespace
	 *  @param searchReplyMessage: the JTella message received from the network
	 */
	public void receiveSearchReply(SearchReplyMessage searchReplyMessage) {
		LOG.info("Received a search reply message from " + searchReplyMessage.getOriginatingConnection().getConnectedServant());
		
		//Parse u-p2p message
		String xmlMessage = searchReplyMessage.getXmlBlock();
		if(xmlMessage == null) {
			// If the XML block was empty, the sender is probably 
			// a node using the old QUERYHIT format
			xmlMessage = searchReplyMessage.getFileRecord(0).getName().trim();
		}
		
		LOG.info("xmlMessage of the search reply: " + xmlMessage);
		try {
			DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
			Document document = db.parse(new ByteArrayInputStream(xmlMessage.getBytes("UTF-8")));
			SearchResponseMessage responseMessage = SearchResponseMessage.parse(document.getDocumentElement());
			
			// Determine the peerIdentifier of the remote peer by using the JTella level IP and port
			String peerIdentifier = searchReplyMessage.getIPAddress() + ":" + searchReplyMessage.getPort();
			
			// Add the mapping of peer IP/Port to client identifier, and remove any
			// previous mapping
			if(peerIdToClientGuid.containsKey(peerIdentifier)) {
				peerIdToClientGuid.remove(peerIdentifier);
			}
			peerIdToClientGuid.put(peerIdentifier, searchReplyMessage.getClientIdentifier());
			LOG.debug("JTellaAdapter: Mapped \"" + peerIdentifier  + "\" to GUID: " 
					+ searchReplyMessage.getClientIdentifier().toString());
			
			if(responseMessage.getHostedResIdList() != null) {
				fireNetworkResourceList(peerIdentifier, responseMessage.getCommunityId(), responseMessage.getHostedResIdList());
				LOG.debug("Fired network resource list.");
			}
			
			if (responseMessage.getResultSetSize() > 0) {
				SearchResponse[] resultSet = responseMessage.getResponses();
				for(SearchResponse response : resultSet) {
					// Rebuild a location entry for each response using the
					// IP / Port determined at the JTella level
					LocationEntry[] locations = new LocationEntry[1];
					locations[0] = new LocationEntry("http://" + searchReplyMessage.getIPAddress()
							+ ":" + searchReplyMessage.getPort() + "/up2p/community/" +
							response.getCommunityId() + "/" + response.getId());
					response.setLocations(locations);
				}
				
				fireTrustMetric(peerIdentifier, responseMessage.getCommunityId(), "Network Distance", 
						Integer.toString(searchReplyMessage.getHops() + 1));
				
				// Fire any other included trust metrics
				List<String> metricNames = responseMessage.getMetricNames();
				if(metricNames != null) {
					for(String metricName : metricNames) {
						fireTrustMetric(peerIdentifier, responseMessage.getCommunityId(), metricName, 
								responseMessage.getTrustMetric(metricName));
					}
				}
				
				fireSearchResponse(resultSet);
				LOG.debug("Fired search responses.");
			}
			
		} 
		catch (ParserConfigurationException e) {
			LOG.error("ParserConfigurationException in JTellaSearchMonitor: " + e.getMessage());
		}
		catch (SAXException e) {
			LOG.error("SAXException in JTellaSearchMonitor: " + e.getMessage());
		} 
		catch (IOException e) {
			LOG.error("IOException in JTellaSearchMonitor: " + e.getMessage());
		} 
		catch (MalformedPeerMessageException e) {
			LOG.error("MalformedPeerMessageException in JTella Adapter: " + e.getMessage());
			LOG.error(e.getStackTrace().toString());
		}
	}

	/**
	 * Handles an incoming PUSH message. Initiates a connection to the remote nodes
	 * PushServlet, and receives transfer requests. Continually requests and pushes
	 * file transfers until an "OK" handshake is received.
	 */
	public void receivePush(PushMessage pushMsg) {
		// TODO: Make a new thread to handle the transfers? Test if doing this
		// in the same thread affects usual message routing.
		
		LOG.debug("JTellaAdapter: Recieved PUSH message from: " 
				+ pushMsg.getIPAddress() + ":" + pushMsg.getPort());
		
		String urlString = "http://" + pushMsg.getIPAddress() + ":" + pushMsg.getPort() + "/up2p/push"
			+ "?" + HttpParams.UP2P_PEERID + "=" + pushMsg.getOriginatingConnection().getPublicIP() 
			+ ":" + adapter.getPort();
		
		LOG.debug("JTellaAdapter: Initiating HTTP connection to: " + urlString);
		
		HttpURLConnection pushConn = null;

		try {
			// open a URL connection to the Servlet
			URL url = new URL(urlString);
			
			boolean pushComplete = false;
			
			while(!pushComplete) {
				// Open a HTTP connection to the URL
				pushConn = (HttpURLConnection) url.openConnection();
				pushConn.setDoInput(true);
				pushConn.setDoOutput(true);
				pushConn.setUseCaches(false);
				pushConn.setRequestMethod("GET");
				
				// Set required request headers
				pushConn.setRequestProperty("Connection", "Keep-Alive");
				pushConn.setRequestProperty("User-Agent","UP2P");
				pushConn.setRequestProperty("Accept","[star]/[star]");
				
				// Read the response from the server
				// This should be either "OK" to signal all transfers are complete, or
				// "GIV comId/resId" to specify a resource to transfer.
	
				BufferedReader inStream = new BufferedReader(new InputStreamReader(pushConn.getInputStream()));
				String serverResponse = inStream.readLine();
				inStream.close();
				LOG.debug("JTellaAdapter: Received from PUSH servlet: " + serverResponse);
				
				if (serverResponse.startsWith("OK")) {
					// If the OK handshake is received, terminate the connection
					LOG.debug("JTellaAdapter: PUSH transfers complete.");
					pushComplete = true;
					
				} else if(serverResponse.startsWith("GIV")) {
					// A transfer request was received, get the community and resource ID
					serverResponse = serverResponse.substring(serverResponse.indexOf(" ") + 1);
					String[] splitResponse = serverResponse.split("/");
					LOG.debug("JTellaAdapter: Got PUSH request for ComId: " + splitResponse[0] + "   ResId: " + splitResponse[1]);
					System.out.println("Got ComId: " + splitResponse[0] + "   ResId: " + splitResponse[1]);
					
					try {
						// Fetch the file paths for the requested resource, and initiate a file transfer
						List<String> filePathList = adapter.lookupFilepaths(splitResponse[0], splitResponse[1]);
						String resourceFilePath = filePathList.remove(0);
						pushResource(pushMsg.getIPAddress() + ":" + pushMsg.getPort(), splitResponse[0],
								resourceFilePath, filePathList);
						
					} catch (ResourceNotFoundException e) {
						LOG.error("JTellaAdapter: Could not find resource specified by PUSH message: " +
								splitResponse[0] + "/" + splitResponse[1]);
					}
				}
				
				// Close the connection once the "OK" handshake is received
				pushConn.disconnect();
			}
			
		} catch (Exception e) {
			LOG.error("JTellaAdapter: PUSH file transfer failed: " + e.getMessage());
			e.printStackTrace();
		}
	}
	
	/**
	 * Send a PUSH message to the specified remote node.
	 * @param peerId	The peer ID of the remote node (IP:port)
	 */
	public void issuePushMessage(String peerId) {
		
		// Get the GUID of the remote node (cached when the query hit was received),
		// and generate a PUSH message
		if(peerIdToClientGuid.get(peerId) == null) {
			LOG.error("JTellaAdapter: PUSH message requested for unknown peer ID: " 
					+ peerId);
			return;
		}
		GUID clientIdentifier = peerIdToClientGuid.get(peerId);
		PushMessage pushRequest = new PushMessage(clientIdentifier, 0,
				c.getRouter().getQueryHitSource(clientIdentifier).getPublicIP(), 
				(short)adapter.getPort());
		
		try {
			// Get the originating connection of the query hit, and send the PUSH message
			NodeConnection clientConnection = c.getRouter().getQueryHitSource(clientIdentifier);
			clientConnection.send(pushRequest);
			LOG.debug("JTellaAdapter: PUSH message sent to client: " + peerId 
					+ " (" + clientIdentifier.toString() + ")");
			LOG.debug("JTellaAdapter: PUSH sent on connection: " + clientConnection.getConnectedServant() 
					+ ":" + clientConnection.getConnectedServantPort());
		} catch (IOException e) {
			LOG.error("JTellaAdapter: Error sending PUSH message.");
			e.printStackTrace();
		}
		
		
	}
	
    //used by network-status.jsp
    public static GNUTellaConnection getConnection() {
    	return c;
    }

    /*
     * @see up2p.core.NetworkAdapter#publish(up2p.repository.ResourceEntry,
     * boolean)
     */
    public void publish(ResourceEntry resourceEntry, boolean buffer) throws NetworkAdapterException {
        // published files are not advertised on the network
    }

    /*
     * @see up2p.core.NetworkAdapter#publishAll(up2p.repository.ResourceList)
     */
    public void publishAll(ResourceList resourceList) throws NetworkAdapterException {
        // published files are not advertised on the network
    }

    /*
     * @see up2p.core.NetworkAdapter#publishFlush()
     */
    public void publishFlush() throws NetworkAdapterException {
        // published files are not advertised on the network
    }

    /*
     * @see up2p.core.NetworkAdapter#remove(up2p.repository.ResourceEntry)
     */
    public void remove(ResourceEntry resourceEntry) throws NetworkAdapterException {
        // published files are not advertised on the network
    }

    /*
     * @see up2p.core.NetworkAdapter#removeAll(up2p.repository.ResourceList)
     */
    public void removeAll(ResourceList resourceList) throws NetworkAdapterException {
        // published files are not advertised on the network
    }

    /**
     * build a list of searchresponse messages (in case we need to break up a large list)
     * from a set of search results
     * @param results
     * @return
     */
    private SearchResponseMessage buildResponseMessages(SearchResponse [] results){
    	//get some important identifiers from the response (they're common to every response in array)
		String communityId= results[0].getCommunityId();
		String qid = results[0].getQueryId();
		
		//TODO handle case where the are several communities in the response
		//TODO: include some XML metadata in the message, and produce several messages limited to 65kb each (!).
		
		// Note: Assumes the IP/Port of the first location for the first result is the local IP/Port (should always
		// be true as this function is only used to generate response messages from local repository
		// results)
		SearchResponseMessage responseMessage = new SearchResponseMessage(qid, communityId);

		// add results to the response
		int resultCount = 0;
		if (results.length > 0) {
			for (SearchResponse r: results) {
				responseMessage.addResult(r);
				resultCount++;
			}
		}

		LOG.info(" -Search returning " + resultCount
				+ " search results for query in community " + communityId);
		return responseMessage;
    }
    
    /**
     * Receives local search responses from the repository, and outputs
     * search response messages to the network.
     */
	public void receiveSearchResponse(SearchResponse[] results) {
		
		LOG.debug(" -Local repository returned " + results.length + " results.");
	
		StringWriter sw2 = new StringWriter();
		
		// Form a search response
		SearchResponseMessage theresponse = buildResponseMessages(results);
		
		// Set the metric list for the response if one exists
		// TODO: Assumes all responses are in the same community,
		// not always strictly true (complex searches?)
		if(metricCache.containsKey(results[0].getCommunityId())) {
			theresponse.setHostedResIdList(metricCache.get(results[0].getCommunityId()));
		}
		
		// Set the number of network neighbours
		int neighbours = 0;
		for(NodeConnection connection : c.getConnectionList()) {
			if (connection.getType() == connection.CONNECTION_INCOMING) {
				neighbours++;
			}
		}
		theresponse.addTrustMetric("Network Neighbours", Integer.toString(neighbours));
		
		// Note: Splitting the message will return the original message wrapped in
		// an array if it is already small enough.
		List<SearchResponseMessage> messagesplit = theresponse.split();
		
		// Restart the procedure with each smaller message
		for (SearchResponseMessage responseMessage : messagesplit){
			
			responseMessage.addTrustMetric("Network Neighbours", Integer.toString(neighbours));
			StringWriter sw = new StringWriter();
			Node requestXML = responseMessage.serialize();

			try {
				TransformerHelper.encodedTransform((Element) requestXML, "UTF-8", sw, true); 
			} catch (IOException e) {
				LOG.error("JTella Adapter:"+e);
				e.printStackTrace();
			}
			
			//get the queryId 
			String qid = responseMessage.getId();
			//output the message
			sendSearchReplyMessage(sw.toString(), qid);
		}
	}

	private void sendSearchReplyMessage(String xmlmsg, String qid){
		LOG.info(" -Sending the search response");
		LOG.debug("content="+xmlmsg);
		
		//get the message of the original query
		LOG.debug("getting original msg with id:"+qid);
		SearchMessage message = messageTable.get(qid) ;

		//TODO: remove messages from the table, periodically.
		//idea: I could make a queue and drop the oldest ones when I reach a size limit
		SearchReplyMessage replyMessage;
		//sometimes the local IP address hasn't been set.

<<<<<<< .mine
		if (adapter.getHost()!=null && message !=null){
			//TODO: set host specific to connection-specific host (as seen by remote host possibly through NAT) and port as general listening port (instead of having link inside XML response)
			replyMessage= new SearchReplyMessage(message, (short)0, adapter.getHost(), 0);
=======
		if (message.getOriginatingConnection().getPublicIP() !=null 
				&& message !=null)
		{
			replyMessage= new SearchReplyMessage(message, (short)adapter.getPort(), 
					message.getOriginatingConnection().getPublicIP(), 0);
>>>>>>> .r556
		if (message.getOriginatingConnection().getPublicIP() !=null 
				&& message !=null)
		{
			replyMessage= new SearchReplyMessage(message, (short)adapter.getPort(), 
					message.getOriginatingConnection().getPublicIP(), 0);
			replyMessage.addCompressedXmlBlock(xmlmsg);

			try {
				// output the response on the Gnutella connection where the search came from
				message.getOriginatingConnection().send(replyMessage);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			LOG.debug("Using public IP address: "
					+ message.getOriginatingConnection().getPublicIP());
			LOG.info("JTellaAdapter: Finished sending search response");
		}
		else if (message==null){
			LOG.error("Error: didn't find original message to reply to...");
			LOG.debug("The remembered messages are: ");
			Iterator<String> iter = messageTable.keySet().iterator();
			while(iter.hasNext()){
				LOG.debug("query identifier :"+ iter.next());	
			}
		}
		else
		{// in the case we don't know the local IP address, we cannot provide a URL to the resources.
			LOG.error("Error: unknown local IP address. Ignoring query response.");
		}
	}
	
	/**
	 * Updates the set of sub-network ID's that this node should
	 * serve (if sub-network support is enabled)
	 * @param subNetIds	A set of U-P2P community IDs (also used as sub-network IDs)
	 */
	public void updateSubnets(Set<String> subNetIds) {
		if(c instanceof SubNetGNUTellaConnection) {
			((SubNetRouter)((SubNetGNUTellaConnection)c).getRouter()).setServedSubNets(subNetIds);
		}
	}
	
	/**
	 * Pushes a resource to a remote peer by connection to upload.jsp and emulating
	 * a web browser upload request.
	 * @param peerId	The IP:port of the remote peer to upload to
	 * @param communityId	The community Id of the resource being uploaded
	 * @param resourceFilePath	The absolute file path to the resource file
	 * @param attachmentFilePaths	A list of absolute file paths to any required resource files
	 */
	private void pushResource(String peerId, String communityId, String resourceFilePath, 
			List<String> attachmentFilePaths) {
		String urlString = "http://" + peerId + "/up2p/upload";
		HttpURLConnection uploadConnection = null;
		DataOutputStream connOutput = null;
		FileInputStream fileInput = null;

		String lineEnd = "\r\n";
		String twoHyphens = "--";
		
		// Arbitrary boundary, might want to make sure it doesn't
		// appear in file contents
		String boundary = "232404jkg4220957934FW";

		int bytesRead, bytesAvailable, bufferSize;
		byte[] buffer;
		int maxBufferSize = 1 * 1024 * 1024;

		try {
			
			// First, ensure all files exist and cancel if they do not
			File resourceFile = new File(resourceFilePath);
			if(!resourceFile.exists()) {
				LOG.error("JTellaAdapter: Resource file could not be found for push: "
						+ resourceFilePath);
				return;
			}
			List<File> attachments = new ArrayList<File>();
			for(String attachmentPath : attachmentFilePaths) {
				File attachFile = new File(attachmentPath);
				if(!attachFile.exists()) {
					LOG.error("JTellaAdapter: Attachment file could not be found for push: "
							+ attachmentPath);
					return;
				}
				attachments.add(attachFile);
			}
			
			LOG.debug("JTellaAdapter: Initiating push to: " + urlString);
			
			// open a URL connection to the Servlet
			URL url = new URL(urlString);

			// Open a HTTP connection to the URL
			uploadConnection = (HttpURLConnection) url.openConnection();
			uploadConnection.setDoInput(true);
			uploadConnection.setDoOutput(true);
			uploadConnection.setUseCaches(false);

			// Set the content type to multipart form data and the method to
			// POST to emulate a browser upload request
			uploadConnection.setRequestMethod("POST");
			uploadConnection.setRequestProperty("Content-Type",
					"multipart/form-data;boundary=" + boundary);
			
			// Set required request headers
			uploadConnection.setRequestProperty("Connection", "Keep-Alive");
			uploadConnection.setRequestProperty("User-Agent","UP2P");
			uploadConnection.setRequestProperty("Accept","[star]/[star]");

			// Open the file output stream and write the community ID and PUSH message parameters
			connOutput = new DataOutputStream(uploadConnection.getOutputStream());
			connOutput.writeBytes(twoHyphens + boundary + lineEnd);
			connOutput.writeBytes("Content-Disposition: form-data; name=\"up2p:community\"" 
					+ lineEnd + lineEnd);
			connOutput.writeBytes(communityId + lineEnd);
			connOutput.writeBytes(twoHyphens + boundary + lineEnd);
			connOutput.writeBytes("Content-Disposition: form-data; name=\"up2p:pushupload\"" 
					+ lineEnd + lineEnd + "true" + lineEnd);
			connOutput.writeBytes(twoHyphens + boundary + lineEnd);
			
			boolean fileWriteComplete = false;
			boolean resourceFileWritten = false;
			File nextFile = null;

			while(!fileWriteComplete) {
				// Determine the next file to be written
				if(!resourceFileWritten) {
					nextFile = resourceFile;
				} else {
					nextFile = attachments.remove(0);
				}
				
				LOG.debug("JTellaAdapter: PUSHing file: " + nextFile.getAbsolutePath());
				
				// Write the file metadata
				connOutput.writeBytes("Content-Disposition: form-data; name=\"up2p:filename\";"
						+ " filename=\"" + nextFile.getName() + "\"" + lineEnd);
				connOutput.writeBytes(lineEnd);
				
				// Open an input stream to the file and allocate a buffer to hold
				// the file contents
				fileInput = new FileInputStream(nextFile);
				bytesAvailable = fileInput.available();
				bufferSize = Math.min(bytesAvailable, maxBufferSize);
				buffer = new byte[bufferSize];
	
				// Read the file and write it to the Http connection
				bytesRead = fileInput.read(buffer, 0, bufferSize);
				while (bytesRead > 0) {
					connOutput.write(buffer, 0, bufferSize);
					bytesAvailable = fileInput.available();
					bufferSize = Math.min(bytesAvailable, maxBufferSize);
					bytesRead = fileInput.read(buffer, 0, bufferSize);
				}
	
				// Send the multipart boundary to indicate the end of the resource file
				connOutput.writeBytes(lineEnd);
				if(attachments.isEmpty()) {
					connOutput.writeBytes(twoHyphens + boundary + twoHyphens + lineEnd);
				} else {
					connOutput.writeBytes(twoHyphens + boundary + lineEnd);
				}
				
				// Set the resource file written flag to true, and finish writing
				// files if the attachment list is empty
				resourceFileWritten = true;
				if(attachments.isEmpty()) { fileWriteComplete = true; }
			}
			
			// Read the server response to ensure the transfer was received
			BufferedReader inStream = new BufferedReader(new InputStreamReader(uploadConnection.getInputStream()));
			while(inStream.readLine() != null);
			inStream.close();		
			
			LOG.debug("JTellaAdapter: Push upload was succesful.");
	
		} catch (MalformedURLException ex) {
			LOG.debug("JTellaAdapter: pushResource Malformed URL: " + ex);
			ex.printStackTrace();
		} catch (IOException ioe) {
			LOG.debug("JTellaAdapter: pushResource IOException: " + ioe);
			ioe.printStackTrace();
		} finally {
			// Close streams
			try {
				if(fileInput != null) { fileInput.close(); }
				if(connOutput != null) { connOutput.flush(); }
				if(connOutput != null) { connOutput.close(); }
				if(uploadConnection != null) { uploadConnection.disconnect(); }
			} catch (IOException e) {
				LOG.error("JTellaAdapter: pushResource failed to close connection streams.");
			}
		}
	}	
}