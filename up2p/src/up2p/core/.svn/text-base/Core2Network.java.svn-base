package up2p.core;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import lights.Field;
import lights.extensions.XMLField;
import lights.interfaces.ITuple;
import lights.interfaces.ITupleSpace;
import lights.interfaces.TupleSpaceException;

import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

import polyester.Worker;

import up2p.peer.jtella.JTellaAdapter;
import up2p.search.SearchMetricListener;
import up2p.search.SearchQuery;
import up2p.search.SearchResponse;
import up2p.search.SearchResponseListener;
import up2p.servlet.DownloadServlet;
import up2p.servlet.HttpParams;
import up2p.tspace.TSScanner;
import up2p.tspace.TupleFactory;
import up2p.tspace.TuplePair;
import up2p.tspace.UP2PWorker;
import up2p.tspace.WorkerInbox;
import up2p.util.Config;
import up2p.xml.TransformerHelper;
import up2p.xml.filter.AttachmentListFilter;
import up2p.xml.filter.AttachmentReplacer;
import up2p.xml.filter.DefaultResourceFilterChain;
import up2p.xml.filter.DigestFilter;
import up2p.xml.filter.FileAttachmentFilter;
import up2p.xml.filter.SerializeFilter;

/**
 * Implementation of <code>WebAdapter</code> which masks the network functionalities for UP2P.
 * Allows the local client to search and download a resource from the network,
 * and interfaces with the downloadservice servlet to provide other UP2P clients with access to the local repository,
 * for search and download. 
 * 
 *  Adapted/refactored from DefaultWebAdapter.
 * 
 * @author Alan Davoust
 * @version 1.0
 */
public class Core2Network implements WebAdapter {
    /** Logger used by this adapter. */
    public static Logger LOG;

   
    

    /** The configuration used for this adapter. */
    protected Config config;


    
    /**
     * The manager of <code>NetworkAdapter</code>s.
     */
    protected JTellaAdapter networkAdapter;


    
    /** 
     * access to the rest of up2p
     */
    private WebAdapter CoreAdapter;
    
    /**
     * Tuple-space worker
     */
    private NetworkWorker tsWorker;
    
  /**the other worker that deals with search responses.*/
    private SearchResponseCollector searchResponseWorker; 

    /**
     * Path to the root directory of the up2p client as returned by the Servlet
     * container.
     */
    private static String rootPath;
    
    /**A special tuple space worker that handles only searchResponses
     * 
     * Used for the purpose of collecting search results by "batches" rather than one at a time, the consequence is that the 
     * @author alan
     *
     */
    private class SearchResponseCollector extends  UP2PWorker {

    	//List<String> activequeryIds; // must contain all Ids of active queries from the network 

    	public SearchResponseCollector(ITupleSpace space) {

    		super(space);

    		this.addQueryTemplate(TupleFactory.createSearchReplyTemplateWithDOM());

    		//activequeryIds = new LinkedList<String>();
    	}


    	@Override
    	public void answerQueries() {

    		List<TuplePair> queries = workerInbox.getAll(); 
    		// this is a synchronized method that will wait while the inbox is empty then, when notified of any new tuples, collect everything.
    		// We will rely on a collection of tuples being dumped all at the same time in the TS rather than one at a time. 

    		List<SearchResponse> allresponses = new ArrayList<SearchResponse>();
    		for (TuplePair tp : queries){

    			ITuple query = tp.query; // tp is a pair (template, query), here we know all templates are the same because this worker only handles one.
    			//each tuple : result of search
    			String comId = ((Field) query.get(1)).toString();
    			String resId = ((Field) query.get(2)).toString();
    			String title = ((Field) query.get(3)).toString();
    			String fname = ((Field) query.get(4)).toString();
    			String location = ((Field) query.get(5)).toString();
    			String qid = ((Field) query.get(6)).toString();

    			LOG.debug("Core2Network::SearchResponseCollector:  SEARCHXPATHANSWER\tqid: " + qid + "\tcomid: " + comId
    					+"\tresid: " + resId + "\tfname: " + fname);

    			/*if(!activequeryIds.contains(qid)) //this means the original search didn't come from the network
    				continue;*/

    			// indicate the location for the file (URL)
    			LocationEntry[] locations = new LocationEntry[1];
    			locations[0] = new LocationEntry(location);

    			SearchResponse newresponse = new SearchResponse(resId , title, comId, fname, locations, false, qid);
    			if (query.length()>7){// the searchresponse has metadata !
    				LOG.debug(name+": search response has metadata");
    				Object metaobj = ((XMLField) query.get(7)).getValue();

    				// Add the metadata to the search response
    				Document metadata = (Document) metaobj;
    				newresponse.addResourceDOM(metadata);
    			}

    			allresponses.add(newresponse);
    		}
    		// Send collection of Search Responses to JTella Adapter. If not originally from the network, will be discarded then... but we've already done a first check using the list activeQueryIds.
    		networkAdapter.receiveSearchResponse(allresponses.toArray(new SearchResponse[0]));

    	}


    	@Override
    	protected List<ITuple> answerQuery(ITuple template, ITuple query)  {
    		throw new UnsupportedOperationException("This method is not implemented."); 
    	}


    	/*
    	/** notify of a query from the network * /
		public void addQid(String qid) {
			activequeryIds.add(qid);
			
		} */

    }


    private class NetworkWorker extends UP2PWorker implements SearchResponseListener, SearchMetricListener {

    	
    	public NetworkWorker(ITupleSpace ts){
    		super(ts);	
    		name= "NETWK"; //a name for this worker
    		
			//add a tuple = template for SearchXPath queries (3 arguments + extent): only interested in searches that go for the network + local.
    		//This worker issues searches with extent = UP2P_SEARCH_LOCAL
    		addQueryTemplate(TupleFactory.createSearchTemplate(HttpParams.UP2P_SEARCH_ALL));
    		
    		//template for search responses. We will ultimately only process those that are from the network.
    		//addQueryTemplate(TupleFactory.createSearchReplyTemplateWithDOM());
    		//update 2011-07-15: search results will be managed by a separate worker in order to have search results grouped.
    		
    		// Template for subnetwork updates (1 argument: Root Community Id)
    		// Does not need query ID as no reply is expected
    		addQueryTemplate(TupleFactory.createQueryTupleTemplate(TupleFactory.UPDATESUBNETS, 1));
    		
    		// Template for push message requests (1 argument: Peer Id)
    		// Does not need query ID as no reply is expected
    		addQueryTemplate(TupleFactory.createQueryTupleTemplate(TupleFactory.PUSHREQUEST, 1));
    		
    		// Template for local browse responses (used to send out hosted resource lists
    		// for trust metric purposes)
    		// 3 arguments:
    		// 1 - Community ID
    		// 2 - Query ID
    		// 3 - List of resource ID's ("/" separated)
    		addQueryTemplate(TupleFactory.createQueryTupleTemplate(TupleFactory.BROWSELOCALCOMMUNITYANSWER, 3));
    		
    		// Template for when a local search returns no results
    		// 2 arguments:
    		// 1 - Community ID
    		// 2 - Query ID
    		addQueryTemplate(TupleFactory.createQueryTupleTemplate(TupleFactory.SEARCHXPATH_NORESULT, 1));
    		
    		// Two fields for REMOVE: <comId, resId>
    		addQueryTemplate(TupleFactory.createQueryTupleTemplate(TupleFactory.REMOVE, 2));

    		// Three fields for PUBLISH: <comId, resId, xmlNode>
    		addQueryTemplate(TupleFactory.createPublishTemplate());
    	}

    	/**
    	 *  Sends out a local search to the tuple space
    	 *  The method is asynchronous. (doesn't wait for an answer)
    	 *  update 2011-07-12: no longer uses QueryListeners
    	 * @param resourceId
    	 * @param communityId
    	 * @param updateResList True if a tuple to update the hosted resource list for the community
    	 * 						should also be generated.
    	 * @param xPath
    	 * @return
    	 */
    	public void searchWithDOM(String communityId, String xPath, //SearchResponseListener listener,
    			String qid) {
    		
    		//define a tuple for this query.
    		LOG.debug(name + " About to put search tuple: arguments "+communityId+", "+xPath+", "
    				+ qid + ", " + HttpParams.UP2P_SEARCH_LOCAL);
    		try {
    			ITuple t3query = TupleFactory.createSearchTuple(communityId, xPath, qid, 
    					HttpParams.UP2P_SEARCH_LOCAL);
    			
    			// Add the query to the list to be ignored so that this worker doesn't 
    			// try to process it
        		//ignoreSearchQuery(t3query);
        		//ITuple t7ans = TupleFactory.createSearchReplyTemplateWithDOM(qid);
        		
    			// Output the desired query
    			space.out(t3query); //asynchronousQuery(t3query, t7ans, listener); //modified: doesn't add the listener
    			//addListener(listener,t7ans);
    		} catch (TupleSpaceException e) {
    			LOG.error(name+" :searchWithDOM: "+ e.toString());
    		}
    		LOG.debug(name+" sent.");

    	}
    	
    	//implements abstract class
    	public List<ITuple> answerQuery(ITuple template_not_used, ITuple query){
    		String verb = ((Field) query.get(0)).toString();
    		
    		if (verb.equals(TupleFactory.SEARCHXPATH)){
    			// Only handle queries whose extent includes the network
    			try {
    				int extent = Integer.parseInt(((Field) query.get(4)).toString());
    				if(extent == HttpParams.UP2P_SEARCH_ALL || extent == HttpParams.UP2P_SEARCH_NETWORK) {
		    			String comId = ((Field) query.get(1)).toString();
		    			String xpath = ((Field) query.get(2)).toString();
		    			String qid = ((Field) query.get(3)).toString();
		
		    			LOG.info("Outputting a network search. Query: "+ xpath);
		    			
		    			//this search is asynchronous (void method)
		    			networkAdapter.searchNetwork(comId, xpath, qid);
    				}
    			} catch (NumberFormatException e) {
    				LOG.error(name + ": Search extent could not be determined, discarding.");
    			}
				
    		} else if (verb.equals(TupleFactory.UPDATESUBNETS)){

    			String rootCommId = ((Field) query.get(1)).toString();
    			try {
    				List<String> subnetList = synchronousLocalBrowse(rootCommId);
        			
        			Set<String> subnetTree = new TreeSet<String>();
        			subnetTree.addAll(subnetList);
        			
        			networkAdapter.updateSubnets(subnetTree);
    			} catch (CommunityNotFoundException e) {
    				LOG.error("Invalid root community ID specified in UpdateSubnets tuple.");
    			}			
    		} else if (verb.equals(TupleFactory.PUSHREQUEST)){
    			
    			String peerId = ((Field) query.get(1)).toString();
    			LOG.debug(name + ": Issuing push request to peer: " + peerId);
        		networkAdapter.issuePushMessage(peerId);
        		
    		} else if (verb.equals(TupleFactory.BROWSELOCALCOMMUNITYANSWER)){
    			
    			String communityId = ((Field) query.get(1)).toString();
    			String queryId = ((Field) query.get(2)).toString();
    			String resourceList = ((Field) query.get(3)).toString();
    			
    			if(resourceList.equals(TupleFactory.COMMUNITY_NOT_FOUND)) {
    				LOG.debug(name + ": Got empty response to local community browse.");
    			} else {
    				networkAdapter.updateResourceList(queryId, communityId, Arrays.asList(resourceList.split("/")));
    			}
    		} else if (verb.equals(TupleFactory.SEARCHXPATH_NORESULT)) {
    			String qid = ((Field) query.get(1)).toString();
    			// networkAdapter.ignoreResourceList(qid);
    			
    		} else if (verb.equals(TupleFactory.REMOVE)
    				|| verb.equals(TupleFactory.PUBLISH))
    		{
    			String comId = ((Field) query.get(1)).toString();
    			networkAdapter.invalidateCachedResourceList(comId);
    		}

    		
    		return new ArrayList<ITuple>();
    	}

		//@Override
		//This is to receive responses from the network. 
		public void receiveSearchResponse(SearchResponse[] responses) {
			
			List<ITuple> answers = new ArrayList<ITuple>();
			
			LOG.debug(name+"got "+ responses.length+" search responses from the network");
			for(SearchResponse resp : responses){
				LOG.debug("A response:"+resp.toString());
				String rid = resp.getId();
				String comId= resp.getCommunityId();
				LocationEntry[] locs = resp.getLocations();
				if (locs.length>1)
					LOG.warn("ReceiveSearchResponse: Warning: there's more than one location returned in this searchresponse from the network");
				String location = locs[0].getLocationString(); 
				
				String title = resp.getTitle();
				String qid = resp.getQueryId();
				String fname = resp.getFileName();
				
				ITuple atuple = TupleFactory.createSearchReply(comId, rid,  title,fname, location, qid);
				
				// if we have metadata, then we output a tuple response with the DOM (avoid the one without, see SearchReponseTree)
				if(resp.getResourceDOM() !=null){ //metadata attached
					ITuple btuple = TupleFactory.createSearchReplyWithDOM(comId, rid, title, fname, location, qid, resp.getResourceDOM());
					answers.add(btuple);
				} else
				{
				answers.add(atuple); // otherwise use the one without metadata 
				}
				
			}
			LOG.debug(name+" outputting "+ answers.size()+" tuples search responses");
			try {
				for (ITuple t: answers){
					space.out(t);	
				}
				
			} catch (Exception e) {
				LOG.error("Yikes!! an error! "+ name+e);
			}
			LOG.debug(name+" done.");
		}

		/*
	     * @see up2p.search.SearchMetricListener#receiveMetricValue
	     */
		@Override
		public void receiveMetricValue(String peerIdentifier,
				String communityId, String metricName, String metricValue) {
			
			ITuple metricTuple = TupleFactory.createTuple(TupleFactory.TRUSTMETRIC,
					new String[] {peerIdentifier, communityId, metricName, metricValue});
			
			try {
				space.out(metricTuple);
			} catch (TupleSpaceException e) {
				LOG.error(name + ": Could not add trust metric value to tuple space.");
				e.printStackTrace();
			}
			
		}

		/*
	     * @see up2p.search.SearchMetricListener#receiveNetworkResourceList
	     */
		@Override
		public void receiveNetworkResourceList(String peerIdentifier,
				String communityId, List<String> netResIds) {
			
			if(netResIds == null || communityId == null) {
				return;
			}
			
			String netIdsString = "";
    		for(String rId : netResIds) {
    			netIdsString += "/" + rId;
    		}
    		netIdsString =  netIdsString.substring(1);
    		
    		LOG.debug(name + ": Got Resource List:\t" + peerIdentifier + "\t" + communityId + "\t" + netIdsString);
    		
    		LOG.debug(name + ": Adding resource list for: " + peerIdentifier + " - " + communityId);
    		ITuple resListTuple = TupleFactory.createTuple(TupleFactory.NETRESOURCELIST,
    				new String[] {peerIdentifier, communityId, netIdsString});
    		
    		try {
    			space.out(resListTuple);
    		} catch (TupleSpaceException e) {
    			LOG.error(name + ": Could not add network resource list to tuple space.");
    		}
		}

		/**
		 * Retrieves a list of absolute file paths for the given resource. The first path.
		 * of the list is the resource file, and any further paths are attachments.
		 * @param communityId	The community Id of the resource to be fetched
		 * @param resourceId	The resource Id of the resource to be fetched
		 * @return	A list of file paths for the given resource, where the first is the
		 * 			resource file and all following paths are attachments
		 */
		public List<String> lookupFilepaths(String communityId, String resourceId) {
			String qid = System.currentTimeMillis() + "lfp"; 
			
			ITuple getQuery = TupleFactory.createTuple(new String[] {TupleFactory.GETRESOURCEFILEPATHS, communityId, resourceId, qid});
			
			ITuple resultTemplate = TupleFactory.createTuple(new String[] {TupleFactory.GETRESOURCEFILEPATHSRES});
			resultTemplate.add(new Field().setType(String.class)); // Resource file path field
			resultTemplate.add(new Field().setType(String.class)); // Attachments file path field
			resultTemplate.add(new Field().setValue(qid)); // Query ID field
			
			ITuple result;
			
			try {
				LOG.debug(name + ": Performing file path lookup for: " + communityId + "/" + resourceId);

				space.out(getQuery);
				result = space.rd(resultTemplate);
				
				String resFilePath = ((Field) result.get(1)).toString();
				String attachmentPaths = ((Field) result.get(2)).toString();
				
				if (resFilePath.equals(TupleFactory.RESOURCE_NOT_FOUND)) {
					return null;
				}
				
				List<String> returnList = new ArrayList<String>();
				returnList.add(resFilePath);
				
				LOG.debug("Got attachment string: " + attachmentPaths);
				for(String attachPath : attachmentPaths.split("\\.\\.\\.")) {
					if(!attachPath.equals("")) {
						returnList.add(attachPath);
					}
				}
				
				return returnList;
				
			
			} catch (Exception e) {
				notifyErrorToUser(e);
				return null;	
			}
		}
		
		/**
		 * @see UP2PWorker.shutdownCleanup()
		 */
		public void shutdownCleanup() {
			Core2Network.this.shutdown();
		}
		
		/**
		 * Output a local browse for the purpose of updating the hosted resource list
		 * passed with searchResults.
		 * @param comId	The community to browse
		 * @param queryId	The queryID to use for the browse request
		 */
		public void fetchHostedResourceList(String comId, String queryId) {
			// Output a local browse on the queried community to determine the
			// hosted resource list for trust metrics
			String[] fields = new String[] {comId, queryId};
			ITuple localBrowse = TupleFactory.createTuple(TupleFactory.BROWSELOCALCOMMUNITY, fields);
			
			try {
				space.out(localBrowse);
			} catch (TupleSpaceException e) {
				LOG.error(name + ": Could not fetch hosted resource list.");
				e.printStackTrace();
			}
		}

		/** output a tuple notifying of the opening or closing of a connection */
		public void notifyConnection(String remoteservent, int port,
				String connectionType, boolean opening) {
			
			String[] fields = new String[] {remoteservent, String.valueOf(port), connectionType, String.valueOf(opening)};
			ITuple notif = TupleFactory.createTuple(TupleFactory.NOTIFYCONNECTION, fields);
			
			try {
				space.out(notif);
			} catch (TupleSpaceException e) {
				LOG.error(name + "error:"+e);
				e.printStackTrace();
			}
			
		}
		
		/**
		 * Notifies the tuple space that a relay message has been received.
		 * @param servingPeerId	The peer ID (hostname:port/urlPrefix) of the peer serving files
		 * @param relayUrl	The URL of the relay to use for downloads
		 * @param relayIdentifier	The peer identifier of the relay pair
		 */
		public void notifyRelayReceived(String servingPeerId, String relayUrl, int relayIdentifier) {
			String[] fields = new String[] {servingPeerId, relayUrl, String.valueOf(relayIdentifier)};
			ITuple relayNotif = TupleFactory.createTuple(TupleFactory.RELAY_RECEIVED, fields);
			try {
				space.out(relayNotif);
			} catch (TupleSpaceException e) {
				LOG.error(name + " Error outputing tuple: " + e);
				e.printStackTrace();
			}
		}
    }

    
    /**
     * Constructs an adapter. UPDATED jan 03, 2008 : removed non-network stuff
     * 
     * @param up2pPath path to the root directory of the client deployment in
     * the Servlet container (e.g. ../webapps/up2p)
     * @param adapter the core WebAdapter that handles the interface towards the repository
     * @param conf the Config object containing some configuration properties for the whole system.
     */
    public Core2Network(String up2pPath, WebAdapter adapter, Config conf) {
    	this.config = conf;
        //batchAdapters = Collections.synchronizedSet(new HashSet<NetworkAdapter>());
        //publishedResources = new HashMap<String,ResourceList>();
        CoreAdapter = adapter; //added because the network needs to access the rest of up2p
        
        // set the directory path for up2p (from DefWA)
        rootPath = up2pPath;
        
        // load the logger
        LOG = Logger.getLogger(WebAdapter.LOGGER);
        
        // create the JTella Network Adapter
        try{
        	networkAdapter =  new JTellaAdapter(config, getUrlPrefix(), this);
        		/*new JTellaAdapter(config.getProperty("up2p.gnutella.incoming", "6346"), 
        			Boolean.parseBoolean(config.getProperty("up2p.gnutella.peerdiscovery", "false")),
        			config.getProperty("networkAdapter.relayPeer", ""), getUrlPrefix(), this);*/
        }
        catch(ExceptionInInitializerError err){
        	err.getCause().printStackTrace();
        }
        networkAdapter.setWebAdapter(this);
        /*networkAdapterManager.setNetworkAdapterDirectory(new File(
                getRealFile(config.getProperty("community.root", "community")
                        + File.separator
                        + config.getProperty("networkAdapter.home",
                                "NetworkAdapter"))));
         */

        // log initial message
        LOG.info(new java.util.Date().toString()
                + "Core2Network Adapter initialized.");
        
        
    }

    /**
     * initialize the local tsworker
     */
    public void initializeTS(ITupleSpace ts) {
    	
    	//tspace = ts; I don't actually need to keep a ref to the tuplespace... just to the worker.
    	tsWorker = new NetworkWorker(ts);
    	tsWorker.start();
    	LOG.debug("Core2Network : tuple space worker started.");
    	
    	// Register the TSWorker to receive network search responses and trust metric data
    	networkAdapter.addSearchResponseListener(tsWorker);
    	networkAdapter.addSearchMetricListener(tsWorker);
    	
       searchResponseWorker = new SearchResponseCollector(ts);
       searchResponseWorker.start();
    }
    
    /**
     * for testing and viewing by jsp
     * @return
     */
    public ITupleSpace getTS(){
    	return tsWorker.getTS();
    }

   /** Perform local search on repository via core webadapter.
     * 
     * @param communityId
     * @param query
     * @return search results as returned by the core webadapter.
     */
    public void searchLocal(String communityId, SearchQuery query, String qid) {
    	//use the one below to get responses with a DOM field

    	tsWorker.searchWithDOM(communityId, query.getQuery(), qid);
    	//searchResponseWorker.addQid(qid); for now not dealing with qids at this level.. otherwise I won't know when to purge these    	
    	
    }
    
    /**
	 * Initiates a asynchronous browse of the specified community.
	 * @param comId	The community to browse
	 * @param queryId	The queryID to use for the browse request
	 */
	public void fetchHostedResourceList(String comId, String queryId) {
		tsWorker.fetchHostedResourceList(comId, queryId);
	}
    
    /**
     * Trims the result set to the maximum desired results, as stored in the
     * search query itself.
     * 
     * @param results original result set
     * @param query search query
     * @return cropped result set
     */
    private SearchResponse[] cropResults(SearchResponse[] results,
            SearchQuery query) {
        // cut down to max results
        if (results != null && results.length > query.getMaxResults()) {
            SearchResponse[] shortenedResults = new SearchResponse[query
                    .getMaxResults()];
            System.arraycopy(results, 0, shortenedResults, 0,
                    shortenedResults.length);
            return shortenedResults;
        }
        return results;
    }


    /**
     * Downloads the attachments found in the given XML resource file.
     * Attachments are identified by their file:<filename> URL scheme and are downloaded
     * using the NetworkAdapter. After downloading, the attachment links in the
     * resource file are modified to reflect the local versions of the files and
     * the resource file is written back to disk.
     * 
     * @param resourceFile the file whose attachments will be processed
     * @param downloadDirectory directory where the resource is found... can be removed if my latest hack works 2010-08-24
     * @param communityId	The community the resource belongs to
     * @param peerId	A peer identifier of the format "hostname:port/urlPrefix" 
     * 					that should be used to generate download URLs
     * @param useRelay	Set to true if the specified peer Identifier is a relay peer (uses a different
     * 					URL format for downloads than standards downloads)
     * @param relayIdentifier	Integer defining a relay pair (ignored if useRelay is not set)
     * @throws NetworkAdapterException when the resource file is not found or an
     * error occurs while parsing the resource
     */
    private void downloadAttachments(File resourceFile,
            File downloadDirectory, String resourceId, String communityId, String peerId, 
            boolean useRelay, int relayIdentifier)
            throws NetworkAdapterException {
    	LOG.debug("Core2Network::downloadAttachments: entering.");
    	
    	try {
	        // Create a filter chain to extract attachment names (without modifying the
    		// resource file)
        	XMLReader reader = TransformerHelper.getXMLReader();
    		DefaultResourceFilterChain chain = new DefaultResourceFilterChain();
    		FileAttachmentFilter attachListFilter = new FileAttachmentFilter("file:");
    		chain.addFilter(attachListFilter);
    		chain.doFilter(reader, new InputSource(new FileInputStream(resourceFile)));
    		Iterator<String> attachmentNames = attachListFilter.getAttachmentNames();
	        
			// Create attachment download directory
			downloadDirectory = new File(downloadDirectory, resourceId);
			
	        // Only create the attachment directory if attachments actually exist
	        if(attachmentNames.hasNext()) {
	            if (!downloadDirectory.exists()) {
	                LOG.debug("Core2Network::downloadAttachments: Creating download directory "
	                        + downloadDirectory.getAbsolutePath());
	                downloadDirectory.mkdirs();
	            }
	        }
	        
	        // Downloaded file has been parsed for attachments.
	        // Iterate over all attachments and download each one.
	            
	        // Keep a table of attachment names and real file names
	        // so we can insert them when we serialize back to disk
	        final Map<String,File> attachmentFileMap = new HashMap<String,File>();
	
	        LOG.debug("downloadAttachments: Initiating attachment downloads");
	        while (attachmentNames.hasNext()) {
	        	
	            String attachName = (String) attachmentNames.next();
	            LOG.debug("downloadAttachments: Attempting to download attachment: " + attachName);
	            
	            File downloadFile = new File(downloadDirectory.getAbsolutePath()
                        + File.separator + attachName);;
	            
	            LOG.debug("downloadAttachments: About to retrieve the attachment: " + attachName);
	            String retreiveUrl;
	            
	            if(useRelay) {
	            	retreiveUrl = "http://" + peerId
	    			+ "/relay?" + HttpParams.UP2P_RELAY_IDENTIFIER + "=" + relayIdentifier
	    			+ "&" + HttpParams.UP2P_COMMUNITY + "=" + communityId
	    			+ "&" + HttpParams.UP2P_RESOURCE + "=" + resourceId
	            	+ "&" + HttpParams.UP2P_FILENAME + "=" + attachName;
	            } else {
	            	retreiveUrl = "http://" + peerId + "/community/" + communityId + "/" + resourceId + "/" + attachName;
	            }
	            
	            try {
	            	networkAdapter.retrieveAttachment(retreiveUrl, downloadFile);
	            	attachmentFileMap.put(attachName, downloadFile);
	            } catch (NetworkAdapterException e1) {
	            	LOG.error("downloadAttachments: Peer (" + peerId
	            			+ ") failed to respond to attachment request ("
	                		+ attachName + ").");
	                continue; // There may be more attachments to download, which will not fail
	            }
	        }
	        
	        LOG.debug("downloadAttachments: Attachments downloaded, updating resource file.");
	        
	        
	        // Write the file back to disk with changed attachment links.
	
	        // Create a list of modified attachment links
	        List<String> modifiedList = new ArrayList<String>(attachListFilter.getAttachmentCount());
	        for (String attachName : attachListFilter.getAttachmentList()) {
	        	modifiedList.add("file:" + attachmentFileMap.get(attachName).getName());
	        }
	        
	        // We serialize the changed file to a then, then delete the old file and
	        // rename the temp one to the new one. This is because we can't read
	        // from a file and write to it at the same time.
	        DefaultResourceFilterChain outChain = new DefaultResourceFilterChain();
	
	        // Use replacer filter to replace links with modified ones
	        outChain.addFilter(new AttachmentReplacer(
	        		attachListFilter.getAttachmentList(), 
	        		modifiedList,
	                "file:"));
	        
	        // Generate a temp file and a filter chain to serialize the resource
	        File tempFile = null;
	        FileOutputStream outStream = null;
	        try {
	            tempFile = File.createTempFile("up2p-", ".tmp", resourceFile
	                    .getParentFile());
	            outStream = new FileOutputStream(tempFile);
	        } catch (IOException e) {
	            throw new NetworkAdapterException("Error creating temp file "
	                    + tempFile.getAbsolutePath() + " for resource download.");
	        }
	        SerializeFilter outFilter = new SerializeFilter(outStream, true,
	                DownloadServlet.ENCODING);
	        outChain.addFilter(outFilter);
	        
	        // Serialize to the temp file
	        String errorMsg = "Error saving the downloaded resource.";
	        try {
	            outChain.doFilter(reader, new InputSource(new FileInputStream(
	                    resourceFile)));
	        } catch (FileNotFoundException e1) {
	            LOG.error(errorMsg, e1);
	            throw new NetworkAdapterException(errorMsg);
	        } catch (SAXException e1) {
	            LOG.error(errorMsg, e1);
	            throw new NetworkAdapterException(errorMsg);
	        } catch (IOException e1) {
	            LOG.error(errorMsg, e1);
	            throw new NetworkAdapterException(errorMsg);
	        }
	
	        // Close the output stream
	        try {
	            outStream.close();
	        } catch (IOException e) {
	            LOG.error("downloadAttachments: Error closing output stream for"
	                    + " serialized resource.", e);
	            throw new NetworkAdapterException(
	                    "Error writing the resource file to disk. The temp file "
	                            + tempFile.getAbsolutePath()
	                            + " could not be closed.");
	        }
	        
	
	        // Delete the old file and rename the new one
	        if (resourceFile.delete()) {
	            if (tempFile.renameTo(resourceFile))
	                LOG.info("downloadAttachments: Wrote downloaded resource back"
	                        + " to disk with changed" + " attachment links.");
	            else {
	                errorMsg = "downloadAttachments: Error renaming the resource with"
	                        + " changed attachment links. Temp file: "
	                        + tempFile.getAbsolutePath();
	                LOG.error(errorMsg);
	                throw new NetworkAdapterException(errorMsg);
	            }
	        } else {
	            errorMsg = "downloadAttachments: Error saving a downloaded resource"
	                    + " to disk. Initial downloaded resource file could"
	                    + " not be deleted so it could not be re-serialized"
	                    + " with new attachment links.";
	            LOG.error(errorMsg);
	            throw new NetworkAdapterException(errorMsg);
	        }
        } catch (FileNotFoundException e2) {
            LOG.error(e2);
            throw new NetworkAdapterException(e2.getMessage());
        } catch (SAXException e2) {
            LOG.error(e2);
            throw new NetworkAdapterException(e2.getMessage());
        } catch (IOException e2) {
            LOG.error(e2);
            throw new NetworkAdapterException(e2.getMessage());
        }
    }


   
    /*
     * @see up2p.core.WebAdapter#getHost()
     */
    public String getHost() { //host is set for the "core" network adapter and the repository
        return CoreAdapter.getHost();
    }

    /*
     * @see up2p.core.WebAdapter#getPort()
     */
    public int getPort() {
        return CoreAdapter.getPort();
    }
    
    /**
     * @see up2p.core.WebAdapter#getUrlPrefix()
     */
    public String getUrlPrefix() {
    	return CoreAdapter.getUrlPrefix();
    }
    
    /**
     * KLUDGE: Made this static to avoid major modifications throughout
     * the WebAdapters, but logically it really shouldn't be
     * 
     * @return	The absolute path for the root directory 
     * 			for this instance of U-P2P.
     */
    public static String getRootPath() {
    	return rootPath;
    }

    /**
     * Translates from a relative path to a real path using the root directory
     * of the up2p application as a base.
     * 
     * @param filePath path of a file relative to the webserver context
     * @return the full path to the file
     */
    private String getRealFile(String filePath) {
        return rootPath + File.separator + filePath;
    }

    /**
     * 
     * Retrieves a file from the network.
     * @param response A searchResponse object referencing the resource to be downloaded
     * @return the URL of the resource to be redirected to the upload servlet. ("/upload? "... "/view.jsp..." )
     * 
     */
    
    /*
     * @see up2p.core.WebAdapter#shutdown()
     */
    public void shutdown() {
        LOG.info(new java.util.Date().toString()
                + " Shutting down the Network adapter  of U-P2P.");
        networkAdapter.shutdown();
        
        //TODO : manage host cache and shutdown network listener??
        
    }

    /** 
     * Downloads a file (and all attachments) from the network either directly
     * from the serving peer, or optionally through a peer relay (uses a different
     * URL format)
     * @param communityId	Community ID of the resource to download
     * @param resId			Resource ID of the resource to download
     * @param filename		Filename to save the resource under
     * @param peerId		The peer ID (hostname:port/urlPrefix) of the node serving files
     * @param useRelay	True if a relay peer should be used (different URL format)
     * @param relayUrl	The URL to the relay peer (ignored if useRelay is not set)
     * @param relayIdentifier	Integer defining a relay pair (ignored if useRelay is not set)
     * @return	A reference to the downloaded resource file, or null if the retreive failed.
     */
	public File retrieveFromNetwork(String communityId, String resId,
			String filename, String peerId, boolean useRelay, String relayUrl,
			int relayIdentifier) throws NetworkAdapterException {
		LOG.info("Retrieving resource " + resId
				+ " from the peer network.");
		if(useRelay) {
			LOG.info("Relay peer specified: " + relayUrl + " (Relay ID: " + relayIdentifier + ")");
		}

		// retrieve from the network and save to local community directory
		File downloadDir = new File(DefaultWebAdapter.getStorageDirectory(communityId));

		if (!downloadDir.exists() && !downloadDir.mkdirs())
			LOG.error("Error creating download directory "
					+ downloadDir.getAbsolutePath());
		
		File resourceFile = new File(downloadDir.getAbsolutePath()
				+ File.separator + filename);
		String url = null;
		if(useRelay) {
			url = "http://" + relayUrl
			+ "/relay?" + HttpParams.UP2P_RELAY_IDENTIFIER + "=" + relayIdentifier
			+ "&" + HttpParams.UP2P_COMMUNITY + "=" + communityId
			+ "&" + HttpParams.UP2P_RESOURCE + "=" + resId;
		} else {
			url = "http://" + peerId //peerid is supposed to be hostname:port/urlPrefix
					+ "/community/" +communityId + "/" + resId;
		}

		LOG.info("Attempting retreive from: " + url);
		
		File downloadedFile = networkAdapter.retrieveFromURL(url, resourceFile);

		if (downloadedFile != null) {
			LOG.info("Downloading attachments for resource " + resId
					+ ".");
			try{
				if(useRelay) {
					downloadAttachments(downloadedFile, downloadDir, resId, communityId, relayUrl, useRelay, relayIdentifier);
				} else {
					downloadAttachments(downloadedFile, downloadDir, resId, communityId, peerId, useRelay, relayIdentifier);
				}
			} catch(NetworkAdapterException e){
				LOG.error(e);
			}
			
			// TODO: Send a notification on successful relay download?
			return downloadedFile;
		}
		else {
			LOG.error("Error retrieving a resource from the network.");
			
			return null;
		}
	}
    
    /** 
     * Downloads a file (and all attachments) from the network directly
     * from the serving peer.
     * @param communityId	Community ID of the resource to download
     * @param resId			Resource ID of the resource to download
     * @param filename		Filename to save the resource under
     * @param peerId		The peer ID (hostname:port/urlPrefix) of the node serving files
     * @return	A reference to the downloaded resource file, or null if the retreive failed.
     */
	public File retrieveFromNetwork(String communityId, String resId,
			String filename, String peerId) throws NetworkAdapterException {
		return this.retrieveFromNetwork(communityId, resId, filename, peerId, false, null, 0);
	}
	
	/**
	 * Retrieves a list of absolute file paths for the given resource. The first path.
	 * of the list is the resource file, and any further paths are attachments.
	 * @param communityId	The community Id of the resource to be fetched
	 * @param resourceId	The resource Id of the resource to be fetched
	 * @return	A list of file paths for the given resource, where the first is the
	 * 			resource file and all following paths are attachments
	 * @throws ResourceNotFoundException 
	 */
	public List<String> lookupFilepaths(String communityId, String resourceId) 
		throws ResourceNotFoundException {
		List<String> returnList = tsWorker.lookupFilepaths(communityId, resourceId);
		if(returnList == null) {
			throw new ResourceNotFoundException(communityId + "/" + resourceId);
		}
		return returnList;
	}

	/**
	 * Notifies (via tuple space) of changes in the connections (connections opening or closing)
	 * @param iP remote host
	 * @param port remote port
	 * @param connectionType INCOMING or OUTGOING
	 * @param opening true if the connection is opening, false if it's closing.
	 */
	public void notifyConnection(String remoteservent, int port, String connectionType,
			boolean opening) {
		while (tsWorker == null){ // this should handle the delay between initialization to finish and the notifications getting in from the network.
			
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				return;
				//e.printStackTrace();
			} // wait until the TS gets initialized.
		}
		tsWorker.notifyConnection(remoteservent, port, connectionType, opening);
	}
	
	/**
	 * Notifies the tuple space that a relay message has been received.
	 * @param servingPeerId	The peer ID (hostname:port/urlPrefix) of the peer serving files
	 * @param relayUrl	The URL of the relay to use for downloads
	 * @param relayIdentifier	The peer identifier of the relay pair
	 */
	public void notifyRelayReceived(String servingPeerId, String relayUrl, int relayIdentifier) {
		tsWorker.notifyRelayReceived(servingPeerId, relayUrl, relayIdentifier);
	}
}