<?xml version="1.0" encoding="UTF-8"?><batch><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;"The prime factors of 13195 are 5, 7, 13 and 29.&#13;&#13;What is the largest prime factor of the number 600851475143 ?"&#13;&#13;This solution uses prime decomposition. The most naive solution would make two passes:&#13;(1) Determine all factors of the number&#13;(2) Work in descending order down the list, checking if each number is prime. Return the first prime found.&#13;&#13;However, this approach is too slow to be feasible for a very large number.&#13;&#13;To overcome this limitation this solution works up the list of all prime numbers in ascending order, checking to see if each is a factor of the given number. If a factor is found, the prime factor is factored out and the process continues with the now smaller factored number. When the original number is fully factored into a list of its prime factors, the largest factor is taken as the solution.</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>-- 3&#13;primeFactor :: (Integral a) =&gt; a -&gt; a&#13;primeFactor n = primeDecomp n 1&#13;    where&#13;        primeDecomp :: (Integral a) =&gt; a -&gt; a -&gt; a&#13;        primeDecomp a b = if (mod a factor) == 0&#13;                            then if div a factor == 1&#13;                                    then factor&#13;                                    else primeDecomp (div a factor) (b + 1)&#13;                            else primeDecomp a (b + 1)&#13;                    where factor = (head [x | x &lt;- [b..], isPrime x])&#13;&#13;isPrime :: (Integral a) =&gt; a -&gt; Bool&#13;isPrime x = if x &lt;= 1&#13;                then False&#13;                else primeCheck x (x - 1)&#13;        where&#13;            primeCheck :: (Integral a) =&gt; a -&gt; a -&gt; Bool&#13;            primeCheck x n = if n == 1&#13;                    then True&#13;                    else&#13;                    if mod x n == 0&#13;                        then False&#13;                        else primeCheck x (n - 1)&#13;&#13;                    &#13;problemThree = primeFactor 600851475143&#13;</Snippet><Tags>haskell euler math</Tags><Title>Project Euler - Problem 3</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.&#13;&#13;Find the sum of all the multiples of 3 or 5 below 1000.</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>import Data.List&#13;             &#13;-- 1&#13;problemOne = sum $ takeWhile (&lt; 1000) $ [x | x &lt;- [1..], mod x 3 == 0 || mod x 5 == 0]</Snippet><Tags>haskell euler math</Tags><Title>Project Euler - Problem 1</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;"2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.&#13;&#13;What is the smallest number that is evenly divisible by all of the numbers from 1 to 20?"</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>-- 5&#13;&#13;isDivTwenty :: (Integral a) =&gt; a -&gt; Bool&#13;isDivTwenty a = isDivCheck a 20&#13;        where&#13;            isDivCheck :: Integral a =&gt; a -&gt; a -&gt; Bool&#13;            isDivCheck _ 1 = True&#13;            isDivCheck a b = if mod a b == 0&#13;                                then isDivCheck a (b - 1)&#13;                                else False&#13;                                &#13;problemFive = head [x | x &lt;- [1..], isDivTwenty x == True]</Snippet><Tags>haskell euler math</Tags><Title>Project Euler - Problem 5</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>An implementation of the Quicksort algorithm in Haskell. The Quicksort algorithm works by selecting a pivot value, and separating the list along this pivot. All values smaller or equal to the pivot are placed in one list, and all values larger than the pivot are placed in another list. The location of the pivot in the final sorted list is known, as the number of values larger and smaller than the pivot are known. The value of the pivot is unimportant, and in this implementation the first value of the list is used as the pivot. The algorithm works recursively, as each smaller list is once again sorted using the Quicksort algorithm.</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>-- QuickSort&#13;quickSort :: (Ord a) =&gt; [a] -&gt; [a]  &#13;quickSort [] = []  &#13;quickSort (x:xs) =   &#13;    let smallSorted = quickSort [a | a &lt;- xs, a &lt;= x]  &#13;        bigSorted = quickSort [a | a &lt;- xs, a &gt; x]  &#13;    in  smallSorted ++ [x] ++ bigSorted&#13;</Snippet><Tags>haskell euler math</Tags><Title>Haskell Quicksort</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;"By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6^(th) prime is 13.&#13;&#13;What is the 10001^(st) prime number?"&#13;&#13;Note that this is a very slow brute force solution. The program simply works up the list of all natural numbers, checking if each number is prime. It will return the list of all 10001 first primes, with the last number in the list as the solution.&#13;</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>-- 7&#13;isPrime :: (Integral a) =&gt; a -&gt; Bool&#13;isPrime x = if x &lt;= 1&#13;                then False&#13;                else primeCheck x (x - 1)&#13;        where&#13;            primeCheck :: (Integral a) =&gt; a -&gt; a -&gt; Bool&#13;            primeCheck x n = if n == 1&#13;                    then True&#13;                    else&#13;                    if mod x n == 0&#13;                        then False&#13;                        else primeCheck x (n - 1)&#13;&#13;&#13;firstPrimes n = take n [x | x &lt;- [1..], isPrime x]&#13;problemSeven = firstPrimes 10001</Snippet><Tags>haskell euler math prime primes</Tags><Title>Project Euler - Problem 7</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the Alien Numbers practice problem for Google Codejam 2008.</Description><Language>Java</Language><License>GPL v3</License><Snippet>package aliennumbers;&#13;&#13;import java.io.*;&#13;&#13;/**&#13; * AlienNumbers &#13; * 2008 Google Codejam&#13; * &#13; * @author Alexander Craig&#13; */&#13;public class AlienNumbers {&#13;&#13;    public static void main(String[] args) {&#13;        BufferedReader in;&#13;        PrintStream out;&#13;        &#13;        try {&#13;            // TODO: Change filename as needed to suit input&#13;            in = new BufferedReader(new FileReader(&quot;A-small.in&quot;));&#13;            out = new PrintStream(new FileOutputStream(&quot;output.txt&quot;));&#13;            int cases = Integer.parseInt(in.readLine());&#13;            System.out.println(cases);&#13;            &#13;            for(int i = 0; i &lt; cases; ++i) {&#13;                String[] data = in.readLine().split(&quot;\\s&quot;);&#13;                System.out.println(&quot;Digit: &quot; + data[0] + &quot; Input Language: &quot; + data[1] + &quot; Output Language: &quot; + data[2]);&#13;                &#13;                // Decode input to standard base 10&#13;                int inputTotal = 0;&#13;                for(int j = 0; j &lt; data[0].length(); ++j) {&#13;                    inputTotal += (Math.pow(data[1].length(), data[0].length() - j) / data[1].length()) * data[1].indexOf(data[0].charAt(j));&#13;                }&#13;                &#13;                // Encode to new digit set&#13;                int numDigits = Math.round((float)(Math.ceil(Math.log(inputTotal + 1) / Math.log(data[2].length()))));&#13;                &#13;                String output = &quot;&quot;;&#13;                int curDigit;&#13;                for(int j = 0; j &lt; numDigits; ++j) {&#13;                    curDigit = inputTotal / Math.round((float)Math.pow(data[2].length(), numDigits - j - 1));&#13;                    output += data[2].charAt(curDigit);&#13;                    inputTotal -= Math.round(Math.pow(data[2].length(), numDigits -j -1) * curDigit);&#13;                }&#13;                &#13;                // Output results&#13;                System.out.println(&quot;Case #&quot; + (i + 1) + &quot;: &quot; + output + &quot;\n&quot;);&#13;                out.println(&quot;Case #&quot; + (i + 1) + &quot;: &quot; + output);&#13;            }&#13;            &#13;            in.close();&#13;            out.close();    &#13;        } catch (Exception e) {&#13;            e.printStackTrace();&#13;        }  &#13;    }&#13;&#13;}&#13;</Snippet><Tags>google codejam competition solution</Tags><Title>Alien Numbers</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A simple model definition which was used in a Rails based Spanish-English dictionary. Special getters exist as the definitions were entered with reference tags ([ref][/ref]) to specify links to other words.</Description><Language>Ruby</Language><License>GPL v3</License><Snippet>class Word &lt; ActiveRecord::Base&#13;  validates_length_of :english, :within =&gt; 1..100&#13;  validates_length_of :spanish, :within =&gt; 1..100&#13;  validates_presence_of :definition&#13;&#13;  def get_def_links&#13;    self.definition.split(/(\[ref\])|(\[\/ref\])/)&#13;  end&#13;&#13;  def get_def_untagged&#13;    self.definition.gsub(/(\[ref\])|(\[\/ref\])/,&apos;&apos;)&#13;  end&#13;end&#13;</Snippet><Tags>database Ruby Rails model</Tags><Title>Rails Model Definition</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:&#13;&#13;1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...&#13;&#13;Find the sum of all the even-valued terms in the sequence which do not exceed four million.&#13;&#13;Note: This particular solution is very slow, and would be greatly improved by using a faster algorithm to calculate Fibonacci numbers.</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>import Data.List&#13;&#13;-- 2&#13;-- Note, recursive approach for calculating fibbonaci numbers is extremely slow&#13;fibb :: Integral a =&gt; a -&gt; a&#13;fibb 0 = 0;&#13;fibb 1 = 1;&#13;fibb n = (fibb (n - 1)) + (fibb (n - 2))&#13;&#13;isEven :: Integral a =&gt; a -&gt; Bool&#13;isEven x = (mod x 2) == 0&#13;&#13;problemTwo = sum $ filter isEven $ takeWhile (&lt; 4000000) $ map fibb [1..]&#13;&#13;</Snippet><Tags>haskell euler math</Tags><Title>Project Euler - Problem 2</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;"2^(15) = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.&#13;&#13;What is the sum of the digits of the number 2^(1000)?"&#13;&#13;The splitNum function takes an integer number and returns an array of each of its individual digits. To solve the problem, 2 ^ 1000 is passed to the function, and the resulting array is summed. Haskell's built in support for very large integers makes this an easy solution.</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>-- 16&#13;splitNum :: Integer -&gt; [Integer]&#13;splitNum x = if x &lt; 10&#13;               then [x]&#13;               else (mod x 10) : splitNum (div x 10)&#13;&#13;problemSixteen :: Integer&#13;problemSixteen = sum $ splitNum (2 ^ 1000)</Snippet><Tags>haskell euler math</Tags><Title>Project Euler - Problem 16</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>The MessagePacket class is used to by Scott and Alex Messenger to send information over a TCP/IP connection.</Description><Language>Java</Language><License>GPL v3</License><Snippet>package saa.server;&#13;&#13;import java.io.Serializable;&#13;&#13;/**&#13; * MessagePacket provides further functionality that sending strings did&#13; * not allow for. Message Packets store their originating client&apos;s name,&#13; * as well as various other properties such as their message type, and a&#13; * descriptive string.&#13; * &#13; * @author Alexander&#13; * @version v0.6.6 Beta 1, June 24 2008&#13; */&#13;public class MessagePacket implements Serializable {&#13;    &#13;    private static final long serialVersionUID = 1;&#13;&#13;    public static final int PRIVATE_MESSAGE = 1;&#13;    public static final int BROADCAST_MESSAGE = 2;&#13;    public static final int UPDATE_CLIENTS = 3;&#13;    public static final int VERIFY_TRUE = 4;&#13;    public static final int VERIFY_FALSE = 5;&#13;    public static final int HEARTBEAT = 6;&#13;    public static final int STATUS_UPDATE = 7;&#13;    public static final int KICK_CLIENT = 8;&#13;    &#13;    /** The type of the packet. */&#13;    private int type;&#13;    /** The sender of the packet. */&#13;    private String sender;&#13;    /** The target of the packet. */&#13;    private String target;&#13;    /** The message sent in the packet */&#13;    private String message;&#13;    &#13;    /**&#13;     * Creates a new MessagePacket.&#13;     * @param type  The type of the packet.&#13;     * @param message   The message contained in the packet.&#13;     * @param sender    The originator of the packet.&#13;     * @param target    The desired receipient of the message (used for private messages).&#13;     */&#13;    public MessagePacket(int type, String message, String sender, String target)&#13;    {&#13;        this.type = type;&#13;        this.message = message;&#13;        this.sender = sender;&#13;        this.target = target;&#13;    }&#13;    &#13;    /**&#13;     * Constructor which takes only the type of the packet, typically used for &#13;     * verify True/False messages.&#13;     * @param type  The type of the message.&#13;     */&#13;    public MessagePacket(int type)&#13;    {&#13;        this.type = type;&#13;        this.message = null;&#13;        this.sender = null;&#13;        this.target = null;&#13;    }&#13;    &#13;    /**&#13;     * @return  The type of the message.&#13;     */&#13;    public int getType()&#13;    {&#13;        return type;&#13;    }&#13;    &#13;    /**&#13;     * @return  The name of the message&apos;s originator.&#13;     */&#13;    public String getSender()&#13;    {&#13;        return sender;&#13;    }&#13;    &#13;    /**&#13;     * @return  The string message in the packet.&#13;     */&#13;    public String getMessage()&#13;    {&#13;        return message;&#13;    }&#13;    &#13;    /**&#13;     * @return  The target name of the packet.&#13;     */&#13;    public String getTarget()&#13;    {&#13;        return target;&#13;    }&#13;    &#13;    /**&#13;     * Sets the packets message to the given string.&#13;     * @param message   The message to be stored in the packet.&#13;     */&#13;    public void setMessage(String message)&#13;    {&#13;        this.message = message;&#13;    }&#13;}&#13;</Snippet><Tags>network messenger instant</Tags><Title>Message Packet</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A sample model definition for Django 1.1 (a web framework using Python). This model is designed to share Pacman&apos;s Perilous Predicament levels with full support for commenting on uploaded levels and uploading high scores. This model uses the standard Django User module to track the uploader of each resource. Thanks to Django, the model definition is independent of the underlying database.</Description><Language>Python</Language><License>GPL v3</License><Snippet>from django.db import models&#13;from django.contrib.auth.models import User&#13;&#13;# Create your models here.&#13;class Level(models.Model):&#13;    uploader = models.ForeignKey(User)&#13;    upload_date = models.DateTimeField(&quot;date uploaded&quot;)&#13;    downloads = models.PositiveIntegerField()&#13;    title = models.CharField(max_length = 200)&#13;    author = models.CharField(max_length = 200)&#13;    description = models.TextField()&#13;    tags = models.CharField(max_length = 200)&#13;    xmllevel = models.FileField(upload_to=&apos;leveldata/&apos;)&#13;    preview_image = models.ImageField(upload_to=&apos;level_previews/&apos;)&#13;&#13;    def average_rating(self):&#13;        comment_list = Comment.objects.filter(level = self)&#13;&#13;        if not comment_list:&#13;            return &quot;Not Rated&quot;&#13;&#13;        rating_total = 0&#13;        for comment in comment_list:&#13;            rating_total += comment.rating&#13;&#13;        return rating_total / float(comment_list.count())&#13;&#13;    def comment_count(self):&#13;        return Comment.objects.filter(level = self).count()&#13;    &#13;    def __unicode__(self):&#13;        return self.title + &quot; - &quot; + self.author;&#13;    &#13;class HighScore(models.Model):&#13;    level = models.ForeignKey(Level)&#13;    user = models.ForeignKey(User)&#13;    upload_date = models.DateTimeField(&quot;date uploaded&quot;)&#13;    moves = models.PositiveIntegerField()&#13;    score = models.IntegerField()&#13;    &#13;class Comment(models.Model):&#13;    level = models.ForeignKey(Level)&#13;    user = models.ForeignKey(User)&#13;    upload_date = models.DateTimeField(&quot;date uploaded&quot;)&#13;    comment_text = models.TextField()&#13;    rating = models.IntegerField()&#13;&#13;    def __unicode__(self):&#13;        return self.level.title + &quot; - &quot; + self.user.username&#13;    &#13;</Snippet><Tags>database python Django model</Tags><Title>Django Model Definitions</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;"n! means n × (n &amp;#8722; 1) × ... × 3 × 2 × 1&#13;&#13;Find the sum of the digits in the number 100!"&#13;&#13;This is essentially the same solution as problem 16, only instead of a very large integer a factorial must be calculated before summing the results of splitNum.</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>-- 20&#13;splitNum :: Integer -&gt; [Integer]&#13;splitNum x = if x &lt; 10&#13;               then [x]&#13;               else (mod x 10) : splitNum (div x 10)&#13;&#13;fact :: Integral a =&gt; a -&gt; a&#13;fact 1 = 1&#13;fact 0 = 0&#13;fact n = n * fact(n - 1)&#13;&#13;problemTwenty = sum $ splitNum (fact 100)</Snippet><Tags>haskell euler math</Tags><Title>Project Euler - Problem 20</Title></CodeSnippet><CodeSnippet><Author>Alexander Craig</Author><Description>A solution to the problem:&#13;&#13;"The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.&#13;&#13;Find the sum of all the primes below two million."&#13;&#13;Note that this is a very slow brute force solution. The program simply checks all natural numbers up to 2000000 to see if they are prime, and sums up the resulting list of primes.</Description><Language>Haskell</Language><License>http://creativecommons.org/licenses/BSD/</License><Snippet>-- 10&#13;isPrime :: (Integral a) =&gt; a -&gt; Bool&#13;isPrime x = if x &lt;= 1&#13;                then False&#13;                else primeCheck x (x - 1)&#13;        where&#13;            primeCheck :: (Integral a) =&gt; a -&gt; a -&gt; Bool&#13;            primeCheck x n = if n == 1&#13;                    then True&#13;                    else&#13;                    if mod x n == 0&#13;                        then False&#13;                        else primeCheck x (n - 1)&#13;&#13;&#13;getPrimes :: (Integral a) =&gt; a -&gt; [a]&#13;getPrimes n = [x | x &lt;- [1..n], isPrime x]&#13;&#13;problemTen = sum $ getPrimes 2000000&#13;</Snippet><Tags>haskell euler math prime primes</Tags><Title>Project Euler - Problem 10</Title></CodeSnippet></batch>