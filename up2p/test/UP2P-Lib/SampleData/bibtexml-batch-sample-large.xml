<?xml version="1.0" encoding="UTF-8"?>
<file>
  <entry id="ksuw5:95">
    <techreport>
      <author>Kulkarni, D.</author>
      <author>Stumm, M.</author>
      <author>Unrau, R.</author>
      <author>Li, W.</author>
      <title>A generalized theory of linear loop transformations</title>
      <institution>Computer Systems Research Institute, University of Toronto</institution>
      <number>CSRI-317</number>
      <type>Technical Report</type>
      <month>Dec</month>
      <year>1994</year>
    </techreport>
  </entry>
  <entry id="kslcr:95">
    <inproceedings>
      <author>Kulkarni, D.</author>
      <author>Stumm, M.</author>
      <title>{CDA} loop transformations</title>
      <booktitle>Third Workshop on Languages, compilers and run-time systems for scalable computers</booktitle>
      <editor>Szymanski, B. K.</editor>
      <editor>Sinharoy, B.</editor>
      <chapter>3</chapter>
      <pages>29-42</pages>
      <publisher>Kluwer Academic Publishers</publisher>
      <address>Boston</address>
      <month>May</month>
      <year>1995</year>
    </inproceedings>
  </entry>
  <entry id="kkics:91">
    <inproceedings>
      <author>Kulkarni, D.</author>
      <author>Kumar, K. G.</author>
      <author>Basu, A.</author>
      <author>Paulraj, A.</author>
      <title>Loop Partitioning for Distributed Memory Multiprocessors as Unimodular Transformations</title>
      <booktitle>ACM International Conference on Supercomputing (ICS)</booktitle>
      <address>Cologne, Germany</address>
      <month>June</month>
      <year>1991</year>
    </inproceedings>
  </entry>
  <entry id="kkdmcc:91">
    <inproceedings>
      <author>Kumar, K. G.</author>
      <author>Kulkarni, D.</author>
      <author>Basu, A.</author>
      <author>Paulraj, A.</author>
      <title>{ALDIMS} - Langauge for Programming Distributed Memory Multiprocessors</title>
      <booktitle>Sixth Distributed Memory Computing Conference</booktitle>
      <address>Portland, Oregon</address>
      <month>April</month>
      <year>1991</year>
    </inproceedings>
  </entry>
  <entry id="kkics:92">
    <conference>
      <author>Kumar, K. G.</author>
      <author>Kulkarni, D.</author>
      <author>Basu, A.</author>
      <title>Deriving Good Transformations for Mapping Nested Loops on Hierarchical Parallel Machines in Polynomial Time</title>
      <booktitle>ACM International Conference on Supercomputing (ICS)</booktitle>
      <address>Washington</address>
      <month>July</month>
      <year>1992</year>
    </conference>
  </entry>
  <entry id="kkicpp:91">
    <conference>
      <author>Kumar, K. G.</author>
      <author>Kulkarni, D.</author>
      <author>Basu, A.</author>
      <title>Generalized Unimodular Loop Transformations for Distributed Memory Multiprocessors</title>
      <booktitle>International Conference on Parallel Processing (ICPP)</booktitle>
      <address>Chicago, MI</address>
      <month>July</month>
      <year>1991</year>
    </conference>
  </entry>
  <entry id="wuicase91-13">
    <techreport>
      <author>Wu, J.</author>
      <author>Saltz, J.</author>
      <author>Berryman, H.</author>
      <author>Hiranandani, S.</author>
      <title>Distributed Memory Compiler Design for Sparse Problems</title>
      <institution>ICASE</institution>
      <year>1991</year>
      <number>91-13</number>
      <type>Report</type>
    </techreport>
  </entry>
  <entry id="salt91-12">
    <techreport>
      <author>Saltz, J.</author>
      <author>Petiton, S.</author>
      <author>Berryman, H.</author>
      <author>Rifkin, A.</author>
      <title>Performance Effects of Irregular Communications Patterns on Massively Parallel Multiprocessors</title>
      <institution>ICASE</institution>
      <year>1991</year>
      <number>91-12</number>
      <type>Report</type>
    </techreport>
  </entry>
  <entry id="icase90-11">
    <techreport>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <title>The Preprocessed Doacross Loop</title>
      <institution>ICASE Interim Report</institution>
      <year>1990</year>
      <number>90-11</number>
      <type>Report</type>
    </techreport>
  </entry>
  <entry id="icase90-13">
    <techreport>
      <author>Berryman, H.</author>
      <author>Saltz, J.</author>
      <title>A Manual for PARTI Runtime Primitives</title>
      <institution>ICASE</institution>
      <type>Interim Report</type>
      <year>1990</year>
      <number>90-13</number>
    </techreport>
  </entry>
  <entry id="icase90-59">
    <techreport>
      <author>Saltz, J.</author>
      <author>Berryman, H.</author>
      <author>Wu, J.</author>
      <title>Runtime Compilation for Multiprocessors, To Appear: Concurrency, Practice and Experience, 1991</title>
      <institution>ICASE</institution>
      <type>Report</type>
      <year>1990</year>
      <number>90-59</number>
    </techreport>
  </entry>
  <entry id="salt86hc">
    <inproceedings>
      <author>Saltz, Joel</author>
      <author>Chen, M. C.</author>
      <title>Automated Problem Mapping: the Crystal Runtime System</title>
      <booktitle>The Proceedings of the Hypercube Microprocessors Conf., Knoxville, TN</booktitle>
      <month>September</month>
      <year>1986</year>
    </inproceedings>
  </entry>
  <entry id="mirc88">
    <inproceedings>
      <author>Mirchandaney, R.</author>
      <author>Saltz, J. H.</author>
      <author>Smith, R. M.</author>
      <author>Nicol, D. M.</author>
      <author>Crowley, Kay</author>
      <title>Principles of Runtime Support for Parallel Processors</title>
      <booktitle>Proceedings of the 1988 ACM International Conference on Supercomputing , St. Malo France</booktitle>
      <month>July</month>
      <pages>140-152</pages>
      <year>1988</year>
    </inproceedings>
  </entry>
  <entry id="crete89">
    <inproceedings>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <author>Crowley, K.</author>
      <title>The DoConsider Loop</title>
      <booktitle>Proceedings of the 1989 ACM International Conference on Supercomputing , Crete, Greece</booktitle>
      <pages>29-40</pages>
      <month>June</month>
      <year>1989</year>
    </inproceedings>
  </entry>
  <entry id="seema-jpdc91">
    <article>
      <author>Hiranandani, S.</author>
      <author>Saltz, J.</author>
      <author>Mehrotra, P.</author>
      <author>Berryman, H.</author>
      <title>Performance of Hashed Cache Data Migration Schemes on Multicomputers</title>
      <journal>Journal of Parallel and Distributed Computing, to appear</journal>
      <volume>12</volume>
      <month>August</month>
      <year>1991</year>
    </article>
  </entry>
  <entry id="salt87siam">
    <article>
      <author>Saltz, J. H.</author>
      <author>Naik, V. K.</author>
      <author>Nicol, D. M.</author>
      <title>Reduction of the Effects of the Communication Delays in Scientific Algorithms on Message Passing MIMD Architectures</title>
      <journal>SIAM J. Sci. Stat. Comput</journal>
      <volume>8</volume>
      <number>1</number>
      <pages>s118</pages>
      <year>1987</year>
    </article>
  </entry>
  <entry id="icase90-34">
    <techreport>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <author>Crowley, K.</author>
      <title>Run-Time Parallelization and Scheduling of Loops, to appear in IEEE Transations on Ccomputers, 1991</title>
      <institution>ICASE</institution>
      <year>1990</year>
      <month>May</month>
      <type>Report</type>
      <number>90-34</number>
    </techreport>
  </entry>
  <entry id="salt86">
    <techreport>
      <author>Saltz, J. H.</author>
      <author>Nicol, D. M.</author>
      <title>Statistical Methodologies for the Control of Dynamic Remapping</title>
      <institution>ICASE</institution>
      <year>1986</year>
      <month>July</month>
      <type>Report</type>
      <number>86-46</number>
      <note>to appear in the Proceedings of the Army Research Workshop on Parallel Processing and Medium Scale Multiprocessors, Palo Alto, California, January 1986.</note>
    </techreport>
  </entry>
  <entry id="salt87a">
    <inproceedings>
      <author>Saltz, J.</author>
      <title>Methods for Automated Problem Mapping</title>
      <booktitle>The IMA Volumes in Mathematics and its Applications. Volume 13: Numerical Algorithms for Modern Parallel Computer Architectures Martin Schultz Editor</booktitle>
      <year>1988</year>
      <publisher>Springer-Verlag</publisher>
    </inproceedings>
  </entry>
  <entry id="wuicpp91">
    <inproceedings>
      <author>Wu, J.</author>
      <author>Saltz, J.</author>
      <author>Hiranandani, S.</author>
      <author>Berryman, H.</author>
      <title>Runtime Compilation Methods for Multicomputers, to appear</title>
      <booktitle>Proceedings of the 1991 International Conference on Parallel Processing</booktitle>
      <year>1991</year>
    </inproceedings>
  </entry>
  <entry id="hyper90seema">
    <inproceedings>
      <author>Mirchandaney, S.</author>
      <author>Saltz, J.</author>
      <author>Mehrotra, P.</author>
      <author>Berryman, H.</author>
      <title>A Scheme for Supporting Automatic Data Migration on Multicomputers</title>
      <booktitle>Proceedings of the Fifth Distributed Memory Computing Conference, Charleston S.C.</booktitle>
      <year>1990</year>
    </inproceedings>
  </entry>
  <entry id="mirc88a">
    <techreport>
      <author>Mirchandaney, R.</author>
      <author>Saltz, J. H.</author>
      <title>Dodynamic: A construct for on-the-fly parallelization of loops</title>
      <institution>Yale University</institution>
      <year>1988</year>
      <number>650</number>
      <note>in preparation</note>
    </techreport>
  </entry>
  <entry id="mirc88b">
    <techreport>
      <author>Saltz, J. H.</author>
      <author>Mirchandaney, R.</author>
      <title>How to schedule complex loops in parallel</title>
      <institution>Yale University</institution>
      <year>1988</year>
      <number>657</number>
    </techreport>
  </entry>
  <entry id="kayspaper">
    <techreport>
      <author>Crowley, K.</author>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <title>An automatic method to generate efficient transformations for distributed memory multiprocessors</title>
      <institution>Yale University</institution>
      <year>1988</year>
      <number>658</number>
    </techreport>
  </entry>
  <entry id="saltsiam87">
    <inproceedings>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <author>Smith, R.</author>
      <author>Crowley, K.</author>
      <author>Nicol, D.</author>
      <title>The PARTY Parallel Runtime System</title>
      <booktitle>Parallel Processing for Scientific Computation, Ed. Gary Rodrigue; Proceedings of the Third SIAM Conference on Parallel Processing for Scientific Computing, Los Angeles, California, December 1-4, 1987</booktitle>
      <pages>335-345</pages>
      <year>1989</year>
    </inproceedings>
  </entry>
  <entry id="salt88icase">
    <techreport>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <author>Baxter, D.</author>
      <title>Run-time Parallelization and Scheduling of Loops</title>
      <institution>ICASE</institution>
      <year>1988</year>
      <month>December</month>
      <number>88-70</number>
      <type>Report</type>
    </techreport>
  </entry>
  <entry id="nicolijpp89">
    <article>
      <author>Nicol, D. M.</author>
      <author>Saltz, J. H.</author>
      <title>Delay Point Schedules for Irregular Parallel Computations</title>
      <journal>International Journal of Parallel Programming</journal>
      <month>February</month>
      <volume>18</volume>
      <number>1</number>
      <page>69-90</page>
      <year>1989</year>
    </article>
  </entry>
  <entry id="icase90-41">
    <techreport>
      <author>Berryman, H.</author>
      <author>Saltz, J.</author>
      <author>Scroggs, J.</author>
      <title>Execution Time Support for Adaptive Scientific Algorithms on Distributed Memory Machines, to appear in Concurrency: Practice and Experience 1991</title>
      <institution>ICASE</institution>
      <year>1990</year>
      <month>May</month>
      <number>90-41</number>
      <type>Report</type>
    </techreport>
  </entry>
  <entry id="crow89hyper">
    <inproceedings>
      <author>Crowley, Kay</author>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <author>Berryman, H.</author>
      <title>Runtime Loop Parallelization for Message Passing Machines</title>
      <year>1989</year>
      <month>March</month>
      <booktitle>Proceedings of the 1989 Hypercube Microprocessors Conf., Monterey, CA</booktitle>
    </inproceedings>
  </entry>
  <entry id="spaa89">
    <inproceedings>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <author>Baxter, D.</author>
      <title>Runtime Parallelization and Scheduling of Loops</title>
      <year>1989</year>
      <month>June</month>
      <booktitle>The Proceedings of the 1st ACM Symposium on Parallel Algorithms and Architectures, Santa Fe, NM</booktitle>
      <pages>303-312</pages>
    </inproceedings>
  </entry>
  <entry id="siamberry90">
    <inproceedings>
      <author>Berryman, H.</author>
      <author>Saltz, J.</author>
      <author>Scroggs, J.</author>
      <title>Execution Time Support for Scientific Programs on Distributed Memory Machines</title>
      <booktitle>Proceedings of the Fourth SIAM Conference on Parallel Processing for Scientific Computing</booktitle>
      <city>Chicago , IL</city>
      <month>December</month>
      <year>1989</year>
    </inproceedings>
  </entry>
  <entry id="saltz89">
    <techreport>
      <author>Crowley, K.</author>
      <author>Saltz, J.</author>
      <author>Mirchandaney, R.</author>
      <author>Berryman, H.</author>
      <title>Run-time Scheduling and Execution of Loops on Message Passing Machines</title>
      <institution>Institute for Computer Applications in Science and Engineering</institution>
      <year>1989</year>
      <type>ICASE Report</type>
      <number>89-7</number>
      <address>Hampton, VA</address>
      <month>January</month>
    </techreport>
  </entry>
  <entry id="kmsb-dmcc5">
    <inproceedings>
      <author>Koelbel, C.</author>
      <author>Mehrotra, P.</author>
      <author>Saltz, J.</author>
      <author>Berryman, H.</author>
      <title>Parallel Loops on Distributed Machines</title>
      <booktitle>Proceedings of the 5th Distributed Memory Computing Conference</booktitle>
      <year>1990</year>
      <pages>1097-1104</pages>
      <address>Charlseton, SC</address>
      <month>April</month>
    </inproceedings>
  </entry>
  <entry id="salt-jpdc90">
    <article>
      <author>Saltz, J.</author>
      <author>Crowley, K.</author>
      <author>Mirchandaney, R.</author>
      <author>Berryman, Harry</author>
      <title>Run-time Scheduling and Execution of Loops on Message Passing Machines</title>
      <journal>Journal of Parallel and Distributed Computing</journal>
      <volume>8</volume>
      <pages>303-312</pages>
      <year>1990</year>
    </article>
  </entry>
  <entry id="steele:anticatch">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>Anticatch</title>
      <authorkey>SteeleGL</authorkey>
      <author>Jr., Guy L. Steele</author>
      <pages>1-2</pages>
      <annote>Cutesy observation that monads allow information to be passed ``back in time'' -- and follows with the question of what would be the anti version of catch and throw. The answer appears to be Y.</annote>
    </inproceedings>
  </entry>
  <entry id="filinski:rec-it">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>Recursion from Iteration</title>
      <authorkey>FilinskiA</authorkey>
      <author>Filinski, Andrzej</author>
      <pages>3-12</pages>
      <annote>Iteration+Callcc are the fundamental operations in CBV -- with recursion being derivable, Recursion is the fundamental operation in CBN. In some sense this makes them duals.</annote>
    </inproceedings>
  </entry>
  <entry id="ito:pailisp">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>On PaiLisp Continuation and its Implementation</title>
      <authorkey>ItoT SeinoT</authorkey>
      <author>Ito, Takayasu</author>
      <author>Seino, Tomohiro</author>
      <pages>73-90</pages>
      <annote>Introduces call-once continuations. That is, continuations that are hobbled to the point of being useful for nothing more complex than thread switching, but that thereby can use stacks.</annote>
    </inproceedings>
  </entry>
  <entry id="okasaki:graph">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>Continuation-passing and Graph Reduction</title>
      <authorkey>OkasakiC LeeP TarditiD</authorkey>
      <author>Okasaki, Chris</author>
      <author>Lee, Peter</author>
      <author>Tarditi, David</author>
      <pages>91-101</pages>
      <annote>A popular evaluation technique for lazy languages is to generate graphs and then do graph rewriting/reduction. This paper points out the correspondence between these graphs and CPS expressions. This paper claims this may be a useful way to compile lazy languages.</annote>
    </inproceedings>
  </entry>
  <entry id="harper:poly-type">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>Polymorphic Type Assignment and CPS Conversion</title>
      <authorkey>HarperR LillibridgeM</authorkey>
      <author>Harper, Robert</author>
      <author>Lillibridge, Mark</author>
      <pages>13-22</pages>
      <annote>Studies the extension of cps transform for the simple typed lambda calculus to the full Damas-Milner polymorphic type assignment system under both call-by-value and call-by-name. Call-by-name works, but the Damas-Milner system under call-by-value must be restricted in order to maintain soundness.</annote>
    </inproceedings>
  </entry>
  <entry id="barbanera:norm-result">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>Continuations and simple types: a strong normalization result</title>
      <authorkey>BarbaneraF BerardiS</authorkey>
      <author>Barbanera, Franco</author>
      <author>Berardi, Stefano</author>
      <pages>23-38</pages>
      <annote>Strong normalization results are shown for a simple typed lambda calculus with continuations. No particular calling convention is assumed - every reduction sequence produces the same result.</annote>
    </inproceedings>
  </entry>
  <entry id="kieburtz:monads">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>Three monads for Continuations</title>
      <authorkey>KiebutzR AgapievB HookJ</authorkey>
      <author>Kiebutz, Richard</author>
      <author>Agapiev, Borislav</author>
      <author>Hook, James</author>
      <pages>39-48</pages>
      <annote>Three monads are presented which reflect different types of continuation semantics. Two of the three reflect non-traditional aspects; one expresses first-class continuations, the other expresses composable continuations.</annote>
    </inproceedings>
  </entry>
  <entry id="murthy:atrans">
    <inproceedings>
      <booktitle>Proceedings of the 1992 ACM Workshop on Continuations</booktitle>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
      <title>Control Operators, Hierarchies, and Psuedo-Classical Type Systems: A-Translation at Work</title>
      <authorkey>MurthyC</authorkey>
      <author>Murthy, Chetan</author>
      <pages>49-71</pages>
      <annote>This paper presents a heirarchy of control operators and a type system which models the operational behaviour of the control operators. They prove a monomorphic simple type system for the heirarchy and prove a subject reduction theorem for an A-Translated type-system.</annote>
    </inproceedings>
  </entry>
  <entry id="cw1992">
    <proceedings>
      <title>Proceedings of the 1992 ACM Workshop on Continuations</title>
      <key>CW</key>
      <year>1992</year>
      <month>June</month>
      <address>San Francisco, U.S.A.</address>
      <pubaddress>New York</pubaddress>
      <organization>Association for Computing Machinery</organization>
    </proceedings>
  </entry>
  <entry id="dbt95a">
    <techreport>
      <author>Blasio, P. Di</author>
      <author>Temperini, M.</author>
      <title>$\lambda\&amp;_{ESI}$-calculus for enhanced strict inheritance</title>
      <institution>Istituto di Analisi dei Sistemi ed Informatica, Consiglio nazionale delle Ricerche, Roma</institution>
      <number>R.401</number>
      <month>February</month>
      <year>1995</year>
    </techreport>
  </entry>
  <entry id="dehewi88">
    <article>
      <author>Detlefs, David L.</author>
      <author>Herlihy, Maurice P.</author>
      <author>Wing, Jeannette M.</author>
      <title>Inheritance of Synchronization and Recovery Properties in Avalon/C++</title>
      <journal>Computer</journal>
      <year>1988</year>
      <pages>57-69</pages>
      <month>December</month>
    </article>
  </entry>
  <entry id="kafulee90">
    <article>
      <author>Kafura, Dennis</author>
      <author>Lee, Keung Hae</author>
      <title>{ACT++}: Building a Concurrent {C++} with Actors</title>
      <journal>joop</journal>
      <year>1990</year>
      <pages>25-37</pages>
      <month>May/June</month>
    </article>
  </entry>
  <entry id="presto">
    <manual>
      <title>The PRESTO User's Manual</title>
      <author>Bershad, Brian N.</author>
      <organization>Department of Computer Science, University of Washington</organization>
      <address>Seattle, Washington 98195</address>
      <year>1991</year>
      <month>October</month>
      <keywords>parallel programming enironment</keywords>
      <keywords>C++</keywords>
      <keywords>shared-memory</keywords>
      <abstract>PRESTO is an environment for writing object-oriented parallel programs in the C++ programming language. It makes few assumptions about the behavior of these programs and the models of parallelism to which they adhere. This paper describes the basic PRESTO primitives and provides examples of their use. A simple programming environment based on Mesa monitors and threads is provided as part of the atandard PRESTO distribution, but this may easily (and efficiently) be abandoned to environments base on other models.</abstract>
    </manual>
  </entry>
  <entry id="c++:exp:879">
    <inproceedings>
      <author>Madany, Peter W.</author>
      <author>Campbell, Roy H.</author>
      <author>Kougiouris, Panos</author>
      <title>Experiences Building an Object-Oriented System in C++</title>
      <pages>35-49</pages>
      <booktitle>TOOLS, International Conf.\ on Technology of Object-Oriented Languages and Systems</booktitle>
      <year>1991</year>
      <location>Paris</location>
      <month>March</month>
    </inproceedings>
  </entry>
  <entry id="madcampkou86">
    <techreport>
      <author>Madany, Peter W.</author>
      <author>Campbell, Roy H.</author>
      <author>Kougiouris, Panos</author>
      <title>Experiences Building an Object-Oriented System in C++</title>
      <institution>Department of Computer Science, University of Illinois at Urbana-Champaign</institution>
      <year>1991</year>
      <number>TR 91-1671</number>
      <address>Urbana, IL 61801</address>
      <abstract>This paper describes the methods and classes that we defined and the tools that we built to augment the C++ language so that it would better support the construction of an object-oriented operating system. To motivate the development of these facilities, we briefly describe Choices, an object-oriented operating system that runs on bare hardware, and its requirements for object-oriented language support. Together theses facilities provide the automatic deletion of unreachable objects, first-class classes, dynamically loadable code for classes, and class-oriented debugging. Because of our experience building Choices, we advocate thes features as useful, simplifying and unifying many aspects of object-oriented systems programming.</abstract>
    </techreport>
  </entry>
  <entry id="ungerer91">
    <inproceedings>
      <author>Ungerer, Theo</author>
      <title>Eine objektorientierte Schnittstelle zur Programmierung von Parallelrechnern</title>
      <booktitle>2nd PASA Workshop Parallele Systeme und Algorithmen (PARS)</booktitle>
      <year>1991</year>
      <pages>11-15</pages>
      <location>Paderborn, Germany</location>
      <organization>GI, ITG</organization>
      <month>October</month>
      <abstract>Das Ziel des hier vorgestellten Projektes ist ies, eine objektorientierte Programmierschnittstelle für die Programmierung von nachrichtengekioppelten Multiprozesorsystemes zu schaffen. Die Schnittstelle besteht in einem eingeschränkten Sprachumfang der sequentiellen, objektorientierten Programmiersprache C++. Der Anwender formuliert Paralletität in seinem Programm explizit auf der abstrakten Ebene von Objekten und Methodenaufrufen. Ein Übersetztungsalgorithmus erzeugt aus den Objekten parallel Programme und aus den Methodenaufrufen die für die Übertragung der Parameter zwischen den parallelen Prgorammen notwendigen Kommunikationsanweisungen. Die aus diesem Programmstil resultierende Programmiermethodik, deren Übertragbarkeit auf weitere objektorientierte Sprachen und die Abbildung auf verschiedene Parallelrechner werden untersucht.</abstract>
    </inproceedings>
  </entry>
  <entry id="edelson92">
    <techreport>
      <author>Edelson, Daniel R.</author>
      <title>Smart Pointers: They're Smart, but They're not Pointers</title>
      <institution>Baskin Center for Computer Engineering and Information Sciences, University of California, Santa Cruz</institution>
      <year>1992</year>
      <number>UCSC-CRL-92-27</number>
      <address>Santa Cruz, CA 95064, USA</address>
      <month>June</month>
      <abstract>There are numerous times when a C++ user could benefit from a pointer variant that has more functionality than is provided by the basic,language-defined pointer. For example, type-accurate garbage collection, reference counting, or transparent references to distributed or persistent objects, might be implemented with classes that provide pointer functionality. The C++ language directly supports one kind of pointer substitute, the smart pointer, in the form of overloadable indirection operators: -&gt; and *. In this paper we evaluate how {\em seamlessly} smart pointers can replace raw pointers. The ideal is for client code not to care whether it is using raw pointers or smart pointers. For example, if a typedef selects whether raw or smart pointers are used throughout the program, changing the value of the typedef should not introduce syntax errors. Unfortunately, C++ does not support pointer substitutes well enough to permit seamless integration. This paper presents the desired behavior of smart pointers in terms of the semantics of raw pointers that the smart pointers try to emulate. Then, we describe several ways of implementing smart pointers. For each, we show cases in which the smart-pointers fail to behave like raw pointers. From among the choices, we explain which is the best for emulating the standard pointer conversions. {\em Accessors} are similar to smart pointers, but have certain advantages. This paper discusses the differences between accessors and smart pointers, and shows why our conclusions about type conversion behavior also apply to accessors. Whether a programmer prefers smart pointers or accessors, this paper shows the limitations and recommends an implementation.</abstract>
    </techreport>
  </entry>
  <entry id="edelson92a">
    <techreport>
      <author>Edelson, Daniel R.</author>
      <title>Precompiling C++ for Garbage Collection</title>
      <institution>Baskin Center for Computer Engineering and Information Sciences, University of California, Santa Cruz</institution>
      <year>1992</year>
      <number>UCSC-CRL-92-28</number>
      <address>Santa Cruz, CA 95064, USA</address>
      <month>June</month>
      <abstract>Our research is concerned with compiler-independent, efficient and convenient garbage collection for C++. Most collectors proposed for C++ have either been implemented in a library or in a compiler. As an intermediate step between those two, this paper proposes using precompilation techniques to augment a C++ source program with code to allow mostly type-accurate garbage collection. There are two key precompiler transformations. The first is automatic generation of {\em smart pointer} classes. The precompiler defines the smart pointer classes and the user utilizes them instead of raw pointers. These smart pointers supply functionality that allows the collector to locate the root set for collection. The second transformation augments the C++ program with code that allows the garbage collector to locate internal pointers within objects. This paper describes the precompiler and the garbage collector. The paper includes a brief (1500 word) survey of related techniques.</abstract>
    </techreport>
  </entry>
  <entry id="ellemtel92">
    <manual>
      <title>Programming in C++: Rules and Recommendations</title>
      <organization>Ellemtel Telecommunications Systems Laboratories</organization>
      <address>Box 1505, 125 25 Älvsjö, Sweden</address>
      <year>1992</year>
      <month>April</month>
    </manual>
  </entry>
  <entry id="lemkequinlan92">
    <inproceedings>
      <author>Lemke, M.</author>
      <author>Quinlan, D.</author>
      <title>{P++}, a {C++} Virtual Shared Grids Based Programming Environment for Architecture-Independent Development of Structural Grid Applications</title>
      <booktitle>Proc. of CONPAR92</booktitle>
      <year>1992</year>
      <location>Lyon, France</location>
      <abstract>P++ is an innovative parallel array class library for structured grid applications on distributed memroy multiproccessor architectrures. It is implemented in standard C++ using a serial array class library and a portable communications library. P++ allows for software development in the preferred serial environment and such sortware to be efficiently run, unchanged, on parallel architectures. The added degree of freedom presented by parallel processing is exploited by use of an optimization module within the array class interface. P++ is based on the combination of SPMD (Single Program Multiple Datastream) programming model with the VSG (Virtual Shared Grids) principle of data parallelism. Besides different grid partitioning strategies, two communication update principles are provided and automatically selected at runtime: Overlap Update for nearest neighbor grid element access and VSG Update for general grid (array) computations. As opposed to general Virtual Shared Memory implementations, VSG allows for obtaining similar parallel performance as for codes based on the traditionally used explicit Message Passing programming model.</abstract>
    </inproceedings>
  </entry>
  <entry id="edelson:92">
    <conference>
      <author>Edelson, D. R.</author>
      <title>A mark-and-sweep collector for C++</title>
      <booktitle>popl92</booktitle>
      <pages>51-58</pages>
      <address>Albuquerque, NM</address>
      <month>January</month>
      <year>1992</year>
    </conference>
  </entry>
  <entry id="sakk88a">
    <inproceedings>
      <author>Sakkinen, Markku</author>
      <editor>Gjessing, S.</editor>
      <editor>Nygaard, K.</editor>
      <title>On the Darker Side of C++</title>
      <booktitle>Proceedings ECOOP '88</booktitle>
      <series>LNCS 322</series>
      <pages>162-176</pages>
      <publisher>Springer Verlag</publisher>
      <address>Oslo</address>
      <month>August</month>
      <year>1988</year>
      <keywords>olit ecoop88</keywords>
    </inproceedings>
  </entry>
  <entry id="gamm89a">
    <inproceedings>
      <author>Gamma, Erich</author>
      <author>Weinand, André</author>
      <author>Marty, Rudolph</author>
      <editor>Cook, S.</editor>
      <title>Integration of a Programming Environment into ET++ - A Case Study</title>
      <booktitle>Proceedings ECOOP '89</booktitle>
      <pages>283-297</pages>
      <publisher>Cambridge University Press</publisher>
      <address>Nottingham</address>
      <month>July</month>
      <year>1989</year>
      <keywords>olit ooplas et++ ecoop89</keywords>
    </inproceedings>
  </entry>
  <entry id="kafu89a">
    <inproceedings>
      <author>Kafura, Dennis G.</author>
      <author>Lee, Keung Hae</author>
      <editor>Cook, S.</editor>
      <title>Inheritance in Actor Based Concurrent Object-Oriented Languages</title>
      <booktitle>Proceedings ECOOP '89</booktitle>
      <pages>131-145</pages>
      <publisher>Cambridge University Press</publisher>
      <address>Nottingham</address>
      <month>July</month>
      <year>1989</year>
      <keywords>olit obcl concurrency act++ inheritance ecoop89 binder(oop) obib(obcp)</keywords>
    </inproceedings>
  </entry>
  <entry id="shap89a">
    <inproceedings>
      <author>Shapiro, Marc</author>
      <author>Gautron, Philippe</author>
      <author>Mossieri, Laurence</author>
      <editor>Cook, S.</editor>
      <title>Persistence and Migration for C++ Objects</title>
      <booktitle>Proceedings ECOOP '89</booktitle>
      <pages>191-204</pages>
      <publisher>Cambridge University Press</publisher>
      <address>Nottingham</address>
      <month>July</month>
      <year>1989</year>
      <keywords>olit c++ ecoop89</keywords>
    </inproceedings>
  </entry>
  <entry id="booc90a">
    <inproceedings>
      <author>Booch, Grady</author>
      <author>Vilot, Michael</author>
      <title>The Design of the C++ Booch Components</title>
      <booktitle>Proceedings OOPSLA/ECOOP '90</booktitle>
      <pages>1-11</pages>
      <month>October</month>
      <year>1990</year>
      <keywords>olit oopsla90 ecoop90</keywords>
      <note>Published as ACM SIGPLAN Notices, volume 25, number 10.</note>
    </inproceedings>
  </entry>
  <entry id="snyd91a">
    <inproceedings>
      <author>Snyder, Alan</author>
      <editor>America, P.</editor>
      <title>Modeling the C++ Object Model, An Application of an Abstract Object Model</title>
      <booktitle>Proceedings ECOOP '91</booktitle>
      <series>LNCS 512</series>
      <pages>1-20</pages>
      <publisher>Springer-Verlag</publisher>
      <address>Geneva, Switzerland</address>
      <month>July</month>
      <year>1991</year>
      <keywords>olit ecoop91</keywords>
    </inproceedings>
  </entry>
  <entry id="carg86a">
    <inproceedings>
      <author>Cargill, T. A.</author>
      <title>Pi: A Case Study in Object-Oriented Programming</title>
      <booktitle>Proceedings OOPSLA '86</booktitle>
      <pages>350-360</pages>
      <month>November</month>
      <year>1986</year>
      <keywords>olit appl pi debugger c++ oopsla86</keywords>
      <note>Published as ACM SIGPLAN Notices, volume 21, number 11.</note>
    </inproceedings>
  </entry>
  <entry id="wein88a">
    <inproceedings>
      <author>Weinand, André</author>
      <author>Gamma, Erich</author>
      <author>Marty, Rudolph</author>
      <title>{ET}++ - An Object-Oriented Application Framework in {C}++</title>
      <booktitle>Proceedings OOPSLA '88</booktitle>
      <pages>46-57</pages>
      <month>November</month>
      <year>1988</year>
      <keywords>olit oopsla88</keywords>
      <note>Published as ACM SIGPLAN Notices, volume 23, number 11.</note>
    </inproceedings>
  </entry>
  <entry id="jerr89a">
    <inproceedings>
      <author>Jerrell, Max E.</author>
      <title>Function Minimization and Automatic Differentiation Using C++</title>
      <booktitle>Proceedings OOPSLA '89</booktitle>
      <pages>169-174</pages>
      <month>October</month>
      <year>1989</year>
      <keywords>olit oopsla89</keywords>
      <note>Published as ACM SIGPLAN Notices, volume 24, number 10.</note>
    </inproceedings>
  </entry>
  <entry id="gautron92">
    <inproceedings>
      <author>Saleh, H.</author>
      <author>Gautron, P.</author>
      <title>A Concurrency Control Mechanism for C++ Objects</title>
      <year>1992</year>
      <booktitle>Proceedings of the ECOOP '91 Workshop on Object-Based Concurrent Computing</booktitle>
      <editor>P. Wegner M. Tokoro, O. Nierstrasz</editor>
      <publisher>Springer-Verlag</publisher>
      <pages>195-210</pages>
      <keywords>olit concurrency obc91</keywords>
    </inproceedings>
  </entry>
  <entry id="weiser89">
    <inproceedings>
      <author>Weiser, Mark</author>
      <author>Demers, Alan</author>
      <author>Hauser, Carl</author>
      <title>The Portable Common Runtime approach to interoperability</title>
      <conference>Proceedings of the 12th ACM Symposium on Operating System Principles</conference>
      <conflocation>Litchfield Park, AZ, 3-6 December 1989</conflocation>
      <journal>Operating Systems Review</journal>
      <volume>23</volume>
      <number>5</number>
      <date>December 1989</date>
      <pages>114-22</pages>
      <key>Weiser89</key>
      <keywords>Weiser89 structural issues</keywords>
      <keywords>PCR</keywords>
      <keywords>garbage collection</keywords>
      <keywords>threads</keywords>
      <keywords>IO incremental loader</keywords>
      <keywords>symbol binding C</keywords>
      <keywords>CommonLisp</keywords>
      <keywords>Cedar</keywords>
      <keywords>language runtime system</keywords>
      <annote>Operating system abstractions do not always reach high enough for direct use by a language or applications designer. The gap is filled by language-specific runtime environments, which become more complex for richer languages (CommonLisp needs more than C++, which needs more than C). But language-specific environments inhibit integrated multi-lingual programming. and also make porting hard (for instance, because of operating system dependencies). To help solve these problems, we have built the Portable Common Runtime (PCR), a language-independent and operating-system-independent base for modern languages. PCR offers four interrelated facilities: storage management (including universal garbage collection), symbol binding (including static and dynamic linking and loading), threads (lightweight processes), and low-level I/O (including network sockets). PCR is ``common'' because these facilities simultaneously support programs in several languages. PCR supports C, Cedar, Scheme, and CommonLisp intercalling and runs pre-existing C and CommonLisp (Kyoto) binaries. PCR is ``portable'' because it uses only a small set of operating system features. The PCR source code is available for use by other researchers and developers.</annote>
    </inproceedings>
  </entry>
  <entry id="loo:c++:286">
    <inproceedings>
      <author>Gautron, Philippe</author>
      <author>Shapiro, Marc</author>
      <title>Two extensions to C++: A Dynamic Link Editor and Inner data</title>
      <booktitle>Proceedings and additional papers, C++ Workshop</booktitle>
      <year>1987</year>
      <page>23-34</page>
      <organization>USENIX</organization>
      <address>Berkeley, CA (USA)</address>
      <month>November</month>
    </inproceedings>
  </entry>
  <entry id="fog">
    <inproceedings>
      <author>Gourhant, Yvon</author>
      <author>Shapiro, Marc</author>
      <title>{FOG/C++}: a Fragmented-Object Generator</title>
      <booktitle>C++ Conference</booktitle>
      <year>1990</year>
      <organization>Usenix</organization>
      <address>San Francisco CA (USA)</address>
      <month>April</month>
    </inproceedings>
  </entry>
  <entry id="budd91">
    <book>
      <author>Budd, Timothy</author>
      <title>An Introduction to Object-Oriented Programming</title>
      <publisher>Addison-Wesley</publisher>
      <year>1991</year>
      <annote>Smalltalk, C++, Object Pascal (Macintosh), and Objective-C (NeXT)</annote>
    </book>
  </entry>
  <entry id="ellis90">
    <book>
      <author>Ellis, Margaret A.</author>
      <author>Stroustrup, Bjarne</author>
      <title>The Annotated C++ Reference Manual</title>
      <publisher>Addison-Wesley</publisher>
      <year>1990</year>
      <annote>C++ ANSI Base Document</annote>
    </book>
  </entry>
  <entry id="stroustrup91">
    <book>
      <author>Stroustrup, Bjarne</author>
      <title>The C++ Programming Language</title>
      <edition>Second Edition</edition>
      <publisher>Addison-Wesley</publisher>
      <year>1991</year>
      <annote>C++</annote>
    </book>
  </entry>
  <entry id="misc-4">
    <article>
      <author>Detlefs, David L.</author>
      <author>Herlihy, Maurice P.</author>
      <author>Wing, Jeannette M.</author>
      <title>Inheritance of Synchronisation and Recovery Properties in Avalon/C++</title>
      <journal>{IEEE} Computer</journal>
      <year>1988</year>
      <pages>57-69</pages>
      <month>December</month>
      <keywords>k-inheritance</keywords>
      <keywords>k-synchronisation</keywords>
      <keywords>k-transactions</keywords>
      <keywords>k-atomicity</keywords>
    </article>
  </entry>
  <entry id="monitors-12">
    <inproceedings>
      <author>Seliger, Robert</author>
      <title>Extending C++ to Support Remote Procedure Call, Concurrency, Exception Handling, and Garbage Collection</title>
      <booktitle>USENIX C++ Conference Proceedings</booktitle>
      <year>1990</year>
      <pages>241-261</pages>
      <address>San Francisco, California</address>
      <month>9-11 April</month>
      <annote>The concurrency mechanism used is a variation of monitors. As such it is not very exciting but it has been integrated quite well into the C++ language. What is most surprising is that Monitors are still being used 16 years after Hoare's paper on them. Not too many other high level synchronisation mechanisms can claim that (Path Expressions being the only other example that springs to mind).</annote>
      <keywords>k-monitors</keywords>
      <keywords>k-C++</keywords>
      <keywords>k-exceptions</keywords>
      <keywords>k-RPC</keywords>
      <keywords>k-garbage-collection</keywords>
    </inproceedings>
  </entry>
  <entry id="jordan91">
    <article>
      <author>Jordan, David</author>
      <title>Instantiation of C++ Objects in Shared Memory</title>
      <journal>Journal of Object-Oriented Programming</journal>
      <year>1991</year>
      <volume>4</volume>
      <number>1</number>
    </article>
  </entry>
  <entry id="lavender91">
    <inproceedings>
      <author>Kafura, D. G.</author>
      <author>Lavender, G.</author>
      <title>Recent Progress in Combining Actor-Based Concurrency with Object-Oriented Programming</title>
      <year>1991</year>
      <month>April</month>
      <volume>2</volume>
      <number>2</number>
      <booktitle>ACM OOPS Messenger, Proceedings OOPSLA/ECOOP 90 workshop on Object-Based Concurrent Systems</booktitle>
      <pages>55-58</pages>
      <keywords>olit obcl concurrency act++ obcs90</keywords>
    </inproceedings>
  </entry>
  <entry id="parrington90">
    <inproceedings>
      <author>Parrington, G. D.</author>
      <title>Reliable Distributed Programming in C++: the Arjuna Approach</title>
      <year>1990</year>
      <month>April</month>
      <booktitle>Second Usenix C++ Conference</booktitle>
      <pages>37-50</pages>
      <address>San Fransisco</address>
    </inproceedings>
  </entry>
  <entry id="ungerer91a">
    <inproceedings>
      <author>Ungerer, Theo</author>
      <title>Parallizing C++-Programs for Transputer Systems</title>
      <booktitle>Proceedings of the Seventeenth EUROMICRO Conference on Hardware and Software Automation</booktitle>
      <year>1991</year>
      <pages>463-470</pages>
      <location>Wien, Austria</location>
      <month>September</month>
    </inproceedings>
  </entry>
  <entry id="bic90">
    <techreport>
      <author>Bic, L.</author>
      <title>Distributing Object Arrays in C++</title>
      <institution>Department of Information and Computer Science, University of California, Irvine</institution>
      <year>1990</year>
      <number>90-35</number>
    </techreport>
  </entry>
  <entry id="yinbicungerer90">
    <inproceedings>
      <author>Yin, M.-L.</author>
      <author>Bic, L.</author>
      <author>Ungerer, T.</author>
      <title>Parallel C++ Programming on the Intel iPSC/2 Hypercube</title>
      <booktitle>Proc. of the Fourth Annual Symposium on Parallel Processing</booktitle>
      <year>1990</year>
      <location>Fullerton, California</location>
      <month>April</month>
    </inproceedings>
  </entry>
  <entry id="yinbicungerer90a">
    <inproceedings>
      <author>Yin, M.-L.</author>
      <author>Bic, L.</author>
      <author>Ungerer, T.</author>
      <title>Parallelizing Static C++ Programs</title>
      <booktitle>Proc. of the TOOLS PACIFIC'90</booktitle>
      <year>1990</year>
      <location>Sydney, Australia</location>
      <month>November</month>
    </inproceedings>
  </entry>
  <entry id="ftoc++">
    <inproceedings>
      <author>Angus, I. G.</author>
      <author>Stolzy, Janice L.</author>
      <title>{Experiences Converting an Application from Fortran to C++: Beyond f2c}.</title>
      <booktitle>C++ at Work Conference</booktitle>
      <month>November</month>
      <year>1991</year>
    </inproceedings>
  </entry>
  <entry id="granruss91">
    <article>
      <author>Granston, Elana D.</author>
      <author>Russo, Vincent F.</author>
      <title>Signature-Based Polymorphism for C++</title>
      <journal>Usenix C++ Conference Proceedings</journal>
      <year>1991</year>
      <key>signatures, polymorphism, C++</key>
    </article>
  </entry>
  <entry id="c++:1019">
    <inproceedings>
      <author>Edelson, Daniel R.</author>
      <title>Smart Pointers: They're Smart, But They're Not Pointers</title>
      <booktitle>C++ Conference</booktitle>
      <year>1992</year>
      <pages>1-19</pages>
      <organization>Usenix</organization>
      <address>Portland, OR (USA)</address>
      <month>August</month>
    </inproceedings>
  </entry>
  <entry id="sos:c++:gc:1040">
    <inproceedings>
      <author>Edelson, Daniel R.</author>
      <title>Precompiling C++ for Garbage Collection</title>
      <booktitle>Proc.\ 1992 International Workshop on Memory Management</booktitle>
      <year>1992</year>
      <publisher>Springer-Verlag</publisher>
      <address>Saint-Malo (France)</address>
      <month>September</month>
    </inproceedings>
  </entry>
  <entry id="dwf1">
    <inproceedings>
      <author>Forslund, D. W.</author>
      <author>
        <others />
      </author>
      <title>{Experiences in Writing a Distributed Particle Simulation Code in C++}.</title>
      <booktitle>USENIX C++ Conference</booktitle>
      <year>1990</year>
    </inproceedings>
  </entry>
  <entry id="dwf2">
    <inproceedings>
      <author>Forslund, David</author>
      <author>
        <others />
      </author>
      <title>{A Distributed Particle Simulation Code in C++}</title>
      <booktitle>Computing in Civil Engineering</booktitle>
      <year>1992</year>
      <month>June</month>
    </inproceedings>
  </entry>
  <entry id="budge_uc++">
    <inproceedings>
      <author>A. C. Robinson K. G. Budge, J. S. Peery</author>
      <title>{High Performance Scientific Computing Using C++}.</title>
      <booktitle>USENIX C++ Conference</booktitle>
      <year>1992</year>
    </inproceedings>
  </entry>
  <entry id="acr_asce">
    <inproceedings>
      <author>Robinson, Allen</author>
      <author>
        <others />
      </author>
      <title>{Massively Parallel Computing, C++ and Hydrocode Algorithms}</title>
      <booktitle>Computing in Civil Engineering</booktitle>
      <year>1992</year>
      <month>June</month>
    </inproceedings>
  </entry>
  <entry id="rhale1">
    <inproceedings>
      <author>Peery, James</author>
      <author>Budge, Kent</author>
      <title>{Experiences in Using C++ to Develop a Next Generation Strong Shock Physics Code}</title>
      <booktitle>Computing in Civil Engineering</booktitle>
      <year>1992</year>
      <month>June</month>
    </inproceedings>
  </entry>
  <entry id="rose87">
    <inproceedings>
      <author>Rose, J.</author>
      <title>{C}*: a {C}++-Like Language for Data-Parallel Computation</title>
      <year>1987</year>
      <month>December</month>
      <booktitle>Proceedings of the 1986 USENIX Workshop on C++</booktitle>
      <address>Santa Fe</address>
      <keywords>connection machine</keywords>
      <keywords>distributed systems</keywords>
      <keywords>programming languages</keywords>
    </inproceedings>
  </entry>
  <entry id="c++:ansi">
    <techreport>
      <author>X3J16, ANSI</author>
      <title>American National Standard for Information Systems -- Programming language -- C++</title>
      <institution>ansi</institution>
      <type>Working Paper for Draft Proposed ANSI,</type>
      <number>latest version</number>
      <note>Publication date and document number are not known. The corresponding ISO working group is WG21</note>
    </techreport>
  </entry>
  <entry id="c++:ansi:proposal">
    <article>
      <author>X3J16, ANSI</author>
      <title>How to Write a C++ Language Extension Proposal for ANSI-X3J16/ISO-WG21</title>
      <journal>sigplan</journal>
      <volume>27</volume>
      <number>6</number>
      <month>June</month>
      <year>1992</year>
      <pages>64-71</pages>
    </article>
  </entry>
  <entry id="c++:gabriel:environment">
    <inproceedings>
      <author>Gabriel, R. P.</author>
      <author>Bourbaki, N.</author>
      <author>Devin, M.</author>
      <author>Dussud, P.</author>
      <author>Gray, D.</author>
      <author>Sexton, H.</author>
      <title>Foundation for a C++ programming environment</title>
      <booktitle>Proceedings of C++ at Work</booktitle>
      <month>September</month>
      <year>1990</year>
    </inproceedings>
  </entry>
  <entry id="c++:cluskey:templates">
    <article>
      <author>McCluskey, Glen</author>
      <author>Murray, Robert B.</author>
      <title>Template Instantiation For C++</title>
      <journal>sigplan</journal>
      <volume>27</volume>
      <number>12</number>
      <month>December</month>
      <year>1992</year>
      <pages>47-56</pages>
      <annote>Reports how template instantation is done in {\tt cfront}.</annote>
    </article>
  </entry>
  <entry id="c++:shopiro:iostream">
    <article>
      <author>Shopiro, Jonathan E.</author>
      <title>An Example of Multiple Inheritance in C++: A Model of the Iostream Library</title>
      <journal>sigplan</journal>
      <year>1989</year>
      <volume>24</volume>
      <number>12</number>
      <pages>32-36</pages>
      <annote>Good explanation of multiple inheritance with exhaustive example.</annote>
    </article>
  </entry>
  <entry id="c++:stavtrup:overloading-joke">
    <article>
      <author>Bj{\o}rn {[actually, Andrew Koenig]} Stavtrup</author>
      <title>A proposal regarding invisible logic for object-oriented languages</title>
      <journal>Journal of Object-Oriented Programming</journal>
      <month>April</month>
      <year>1992</year>
      <pages>63-65</pages>
      <note>(Check the contatenation of the title word's first character)</note>
      <annote>This is one of the better fun articles I've seen. Koenig (with input from Stroustrup) describes a C++ language extension proposal: Overloading of whitespace shall be possible. `Whitespace overloading functions' (WOF) will allow to execute implicitly all kind of stuff depending on the formatting of the code.\\ One shouldn't let the background unnoticed: The article notes ``Any similarity between this proposal and any other proposal for extensions to C++ [\dots] is purely coincidental.'' This might be questioned; Koenig's and Stroustrup's comments on the Net about Jim Adcock's proposal (to allow overloading of the dot operator) are too similar to this satire.</annote>
    </article>
  </entry>
  <entry id="c++:stroustrup:mi">
    <inproceedings>
      <author>Stroustrup, Bjarne</author>
      <title>Multiple Inheritance for C++</title>
      <booktitle>Proceedings of the Spring '87 EUUG Conference</booktitle>
      <address>Helsinki</address>
      <month>May</month>
      <year>1987</year>
      <annote>Haven't seen it yet. Is said to announce the MI concept of C++. Perhaps it's a good design reference.</annote>
    </inproceedings>
  </entry>
  <entry id="c++:stroustrup:oop">
    <article>
      <author>Stroustrup, Bjarne</author>
      <title>What is ``Object-Oriented Programming''?</title>
      <journal>IEEE Software</journal>
      <volume>5</volume>
      <number>3</number>
      <month>May</month>
      <year>1988</year>
      <pages>10-20</pages>
      <annote>From the viewpoint of a practioner; does not care for the models behind OOP. Everything that's done by C++ is OOP and is good. There is a revised version available by anonymous ftp which has even more of this tendency. But this is a good article for students to get them in contact with the usefulness of OOP.</annote>
    </article>
  </entry>
  <entry id="krasic96">
    <mastersthesis>
      <author>Krasic, Charles C.</author>
      <title>Parametric Overloading in ML</title>
      <school>University of Waterloo</school>
      <year>1996</year>
    </mastersthesis>
  </entry>
  <entry id="moreau-deroure-foster:europar97">
    <inproceedings>
      <author>Moreau, Luc</author>
      <author>DeRoure, David</author>
      <author>Foster, Ian</author>
      <title>NeXeme: a Distributed Scheme Based on Nexus</title>
      <booktitle>Third International Europar Conference (EURO-PAR'97)</booktitle>
      <series>lncs</series>
      <year>1997</year>
      <month>August</month>
      <publisher>Springer-Verlag</publisher>
      <address>Passau, Germany</address>
    </inproceedings>
  </entry>
  <entry id="moreau-queinnec:rr97">
    <techreport>
      <author>Moreau, Luc</author>
      <author>Queinnec, Christian</author>
      <title>On the Finiteness of Resources in Distributed Computing</title>
      <institution>INRIA</institution>
      <year>1997</year>
      <type>Research Report</type>
      <number>RR-3147</number>
      <month>April</month>
      <abstract>Millions of computers are now connected together by the Internet. At a fast pace, applications are taking profit of these new capabilities, and become parallel and distributed, e.g. applets on the WWW or agent technology. As we live in a world with finite resources, an important challenge is to be able to control computations in such an environment. For instance, a user might like to suspend a computation because another one seems to be more promising. In this paper, we present a paradigm that allows the programmer to monitor and control computations, whether parallel or distributed, by mastering their resource consumption.</abstract>
    </techreport>
  </entry>
  <entry id="moreau-queinnec:dsl97">
    <inproceedings>
      <author>Moreau, Luc</author>
      <author>Queinnec, Christian</author>
      <title>Design and Semantics of Quantum: a Language to Control Resource Consumption in Distributed Computing</title>
      <booktitle>Usenix Conference on Domain-Specific Languages (DSL'97)</booktitle>
      <address>Santa-Barbara, California</address>
      <year>1997</year>
      <pages>183-197</pages>
      <month>October</month>
      <abstract>This paper describes the semantics of Quantum, a language that was specifically designed to control resource consumption of distributed computations, such as mobile agent style applications. In Quantum, computations can be driven by mastering their resource consumption. Resources can be understood as processors cycles, geographical expansion, bandwidth or duration of communications, etc. We adopt a generic view by saying that computations need energy to be performed. Quantum relies on three new primitives that deal with energy. The first primitive creates a tank of energy associated with a computation. Asynchronous notifications inform the user of energy exhaustion and computation termination. The other two primitives allow us to implement suspension and resumption of computations by emptying a tank and by supplying more energy to a tank. The semantics takes the form of an abstract machine with explicit parallelism and energy-related primitives.</abstract>
    </inproceedings>
  </entry>
  <entry id="spi93">
    <article>
      <title>Implementing Haskell: Language Implementation as a Tool Building Exercise</title>
      <author>Spinellis, Diomidis</author>
      <journal>Structured Programming</journal>
      <volume>14</volume>
      <pages>37-48</pages>
      <year>1993</year>
      <url>http://kerkis.math.aegean.gr/dspin/pubs/jrnl/1993-StrProg-Haskell/html/exp.html</url>
    </article>
  </entry>
  <entry id="spi93b">
    <article>
      <title>Checking C Declarations at Link Time</title>
      <author>Spinellis, Diomidis</author>
      <journal>The Journal of C Language Translation</journal>
      <month>March</month>
      <volume>4</volume>
      <number>3</number>
      <pages>238-249</pages>
      <year>1993</year>
      <url>http://kerkis.math.aegean.gr/dspin/pubs/jrnl/1993-JCLT-CType/html/tsl.html</url>
    </article>
  </entry>
  <entry id="sde94">
    <inproceedings>
      <title>Language and Architecture Paradigms as Object Classes: A Unified Approach Towards Multiparadigm Programming</title>
      <author>Spinellis, Diomidis</author>
      <author>Drossopoulou, Sophia</author>
      <author>Eisenbach, Susan</author>
      <booktitle>Programming Languages and System Architectures International Conference</booktitle>
      <address>Zurich, Switzerland</address>
      <month>Mar</month>
      <year>1994</year>
      <pages>191-207</pages>
      <editor>Gutknecht, Jürg</editor>
      <publisher>Springer-Verlag</publisher>
      <note>Lecture Notes in Computer Science 782</note>
      <url>http://kerkis.math.aegean.gr/dspin/pubs/conf/1994-PLSA-Multipar/html/paper.html</url>
    </inproceedings>
  </entry>
  <entry id="spi94c">
    <phdthesis>
      <address>London, UK</address>
      <author>Spinellis, Diomidis</author>
      <month>February</month>
      <school>Imperial College of Science, Technology and Medicine</school>
      <title>Programming Paradigms as Object Classes: A Structuring Mechanism for Multiparadigm Programming</title>
      <year>1994</year>
    </phdthesis>
  </entry>
  <entry id="sde95">
    <article>
      <title>Object-Oriented Technology in Multiparadigm Language Implementation</title>
      <author>Spinellis, Diomidis</author>
      <author>Drossopoulou, Sophia</author>
      <author>Eisenbach, Susan</author>
      <journal>Journal of Object-Oriented Programming</journal>
      <year>1995</year>
      <volume>8</volume>
      <number>1</number>
      <month>March/April</month>
      <pages>33-38</pages>
      <url>http://kerkis.math.aegean.gr/dspin/pubs/jrnl/1995-JOOP-Multipar/html/paper.html</url>
    </article>
  </entry>
  <entry id="spi91c">
    <article>
      <title>Type-safe Linkage for Variables and Functions</title>
      <author>Spinellis, Diomidis</author>
      <journal>sigplan</journal>
      <volume>26</volume>
      <number>8</number>
      <pages>74-79</pages>
      <month>August</month>
      <year>1991</year>
      <where>IC-photocopy</where>
      <keys>Linking Have</keys>
      <url>http://kerkis.math.aegean.gr/dspin/pubs/jrnl/1991-SIGPLAN-CType/html/tsl.html</url>
    </article>
  </entry>
  <entry id="dyrseth:masters">
    <mastersthesis>
      <author>Dyrseth, Arild</author>
      <title>High Performance Fortran?</title>
      <school>Department of Informatics, Univeristy of Bergen</school>
      <month>Jan</month>
      <year>1997</year>
      <note>http://www.ii.uib.no/ arild/master/</note>
    </mastersthesis>
  </entry>
  <entry id="dokpro92">
    <techreport>
      <author>Anoraganingrum, Djati Adi Wicaksono Dwi</author>
      <title>DokPro v.1.0 - Dokter Administration System - With Clipper 5.1</title>
      <year>1992</year>
      <month>December</month>
    </techreport>
  </entry>
  <entry id="novillo.ea-98">
    <inproceedings>
      <author>Novillo, Diego</author>
      <author>Unrau, Ron</author>
      <author>Schaeffer, Jonathan</author>
      <title>Concurrent SSA Form in the Presence of Mutual Exclusion</title>
      <booktitle>Proceedings of the 1998 International Conference on Parallel Processing (ICPP'98)</booktitle>
      <month>Aug</month>
      <year>1998</year>
      <pages>356-364</pages>
      <url>http://www.cs.ualberta.ca/diego/Papers/icpp98.ps</url>
      <abstract>Most current compiler analysis techniques are unable to cope with the semantics introduced by explicit parallel and synchronization constructs in parallel programs. In this paper we propose new analysis and optimization techniques for compiling explicitly parallel programs that use mutual exclusion synchronization. We introduce the CSSAME form, an extension of the Concurrent Static Single Assignment (CSSA) form that incorporates mutual exclusion into a data flow framework for explicitly parallel programs. We show how this analysis can improve the effectiveness of constant propagation in a parallel program. We also modify a dead-code elimination algorithm to work on explicitly parallel programs. Finally, we introduce lock independent code motion, a new optimization technique that attempts to minimize the size of critical sections in the program.</abstract>
    </inproceedings>
  </entry>
  <entry id="lastovetsky97">
    <conference>
      <author>Arapov, Dmitry</author>
      <author>Kalinov, Alexey</author>
      <author>Lastovetsky, Alexey</author>
      <title>Resource Management in the mpC Programming Environment</title>
      <booktitle>Proceedings of the 30th Hawaii International Conference on System Sciences (HICSS'30)</booktitle>
      <address>Maui, Hawaii</address>
      <publisher>IEEE Computer Society Press</publisher>
      <month>January #</month>
    </conference>
  </entry>
  <entry id="pottier-phd-english-98">
    <techreport>
      <author>Pottier, François</author>
      <title>Type inference in the presence of subtyping: from theory to practice</title>
      <institution>INRIA</institution>
      <number>3483</number>
      <month>September</month>
      <year>1998</year>
      <documenturl>ftp://ftp.inria.fr/INRIA/publication/RR/RR-3483.ps.gz</documenturl>
    </techreport>
  </entry>
  <entry id="pottier-phd-french-98">
    <phdthesis>
      <author>Pottier, Francois</author>
      <title>Synthèse de types en présence de sous-typage: de la théorie à la pratique</title>
      <school>Université Paris VII</school>
      <month>July</month>
      <year>1998</year>
      <documenturl>http://pauillac.inria.fr/fpottier/publis/these-fpottier.ps.gz</documenturl>
    </phdthesis>
  </entry>
  <entry id="gaissaryan95">
    <article>
      <author>Gaissaryan, Sergey S.</author>
      <author>Khaletsky, Dmitry A.</author>
      <author>Lastovetsky, Alexey L.</author>
      <author>Ledovskih, Ilya N.</author>
      <title>Extension of ANSI C for vector and superscalar computers</title>
      <journal>Programming and Computer Software</journal>
      <volume>21</volume>
      <number>1</number>
      <month>January</month>
      <year>1995</year>
    </article>
  </entry>
  <entry id="pottier-icfp-98">
    <inproceedings>
      <author>Pottier, Fran{\c}ois</author>
      <institution>INRIA</institution>
      <title>A Framework for Type Inference with Subtyping</title>
      <booktitle>Proceedings of the third ACM SIGPLAN International Conference on Functional Programming (ICFP '98)</booktitle>
      <month>September</month>
      <year>1998</year>
      <pages>228-238</pages>
      <documenturl>http://pauillac.inria.fr/fpottier/publis/fpottier-icfp98.ps.gz</documenturl>
    </inproceedings>
  </entry>
  <entry id="gomi97">
    <inproceedings>
      <author>Ottosson, Greger</author>
      <author>Sjödin, Mikael</author>
      <title>Worst-Case Execution Time Analysis for Modern Hardware Architectures</title>
      <booktitle>ACM SIGPLAN 1997 Workshop on Languages, Compilers, and Tools for Real-Time Systems (LCT-RTS'97)</booktitle>
      <year>1997</year>
      <organization>ACM</organization>
      <month>June</month>
    </inproceedings>
  </entry>
  <entry id="carott96">
    <inproceedings>
      <author>Carlsson, Mats</author>
      <author>Ottosson, Greger</author>
      <title>Anytime Frequency Allocation with Soft Constraints</title>
      <booktitle>CP96 Pre-Conference Workshop on Applications</booktitle>
      <year>1996</year>
    </inproceedings>
  </entry>
  <entry id="carott97">
    <inproceedings>
      <author>Carlsson, Mats</author>
      <author>Ottosson, Greger</author>
      <author>Carlson, Björn</author>
      <title>An Open-ended Finite Domain Constraint Solver</title>
      <booktitle>Ninth International Symposium on Programming Languages, Implementations, Logics, and Programs (PLILP'97)</booktitle>
      <volume>1292</volume>
      <series>Lecture Notes in Computer Science</series>
      <year>1997</year>
      <publisher>Springer-Verlag, Berlin</publisher>
      <month>September</month>
    </inproceedings>
  </entry>
  <entry id="hdr-f-maraninchi97">
    <techreport>
      <author>Maraninchi, F.</author>
      <title>Modélisation et validation des systèmes réactifs : un langage synchrone à base d'automates</title>
      <type>Document d'Habilitation à Diriger des Recherches</type>
      <institution>Université Joseph Fourier, Grenoble</institution>
      <address>Grenoble</address>
      <month>May</month>
      <note>in french</note>
      <url>http://www-verimag.imag.fr/PEOPLE/Florence.Maraninchi/</url>
      <annote>Ce document décrit la conception du langage Argos. C'est un langage synchrone à syntaxe graphique, qui permet la description de systèmes réactifs sous forme de compositions de machines de Mealy. Le jeu d'opérateurs est en quelque sorte minimal : mise en parallèle, synchronisation par le mécanisme de diffusion synchrone commun à tous les langages synchrones, composition hiérarchique héritée des Statecharts. La composition parallèle de machines à états et la composition hiérarchique rendent réaliste la description de systèmes de taille conséquente par des systèmes d'états et de transitions explicites. Nous décrivons la démarche de conception du langage : problèmes liés au choix des constructions et à leur sémantique ; implantation efficace ; connexions du compilateur à divers outils de vérification du domaine ; génération de code. Nous présentons également les extensions du langage proposées pour la spécification des systèmes temporisés, hybrides ou non-déterministes, et les expériences de programmation multi-langages menées dans le cadre synchrone avec Esterel et Lustre. Nous montrons les relations étroites entre la définition d'Argos et certains aspects de l'enseignement de l'algorithmique en Deug. Mots-clé: Systèmes réactifs, langages synchrones, modélisation, programmation, validation, automates, Argos, algorithmique This document is about the design of the Argos language. It's a synchronous language, in which reactive systems are described as compositions of Mealy machines. The set of operators is in some sense minimal: the parallel composition; the synchronous broadcast common to all synchronous languages, as the communication mechanism; a hierarchic composition inspired from Statecharts. The parallel and hierarchic compositions allow the description of large systems bt means of explicit states and transitions. We described the design phases of the language: choice of the construct, and definition of their semantics; efficient implementation; connections of the compiler to a wide variety of available verification tools; code generation. We also mention the extensions towards timed, hybrid or non-deterministic systems, and the experience in multi-language programming in the synchronous framework: Argos+Lustre or Argos+Esterel. We show relationships between the definition of Argos and the teaching of algorithmics. Keywords: Reactive Systems, synchronous languages, modelling, programming, validation, automata, Argos, algorithmics</annote>
      <year>1997</year>
    </techreport>
  </entry>
  <entry id="loulergue_renpar10">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{BSML} : programmation {BSP} purement fonctionnelle</title>
      <booktitle>{RENPAR'10}, Rencontres francophones du paralllisme</booktitle>
      <year>1998</year>
      <month>Juin</month>
      <abstract-url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/renpar10_abstract.txt</abstract-url>
      <url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/renpar10.ps.gz</url>
      <organization>Université de Strasbourg</organization>
    </inproceedings>
  </entry>
  <entry id="lhf_cmpp98">
    <inproceedings>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <author>Foisy, C.</author>
      <title>A Calculus of Recursive-Parallel BSP Programs</title>
      <booktitle>{CMPP'98} International Workshop on Constructive Methods for Parallel Programming</booktitle>
      <year>1998</year>
      <address>{M}arstrand, {S}weden</address>
      <month>June</month>
      <abstract-url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/cmpp98_abstract.txt</abstract-url>
      <url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/cmpp98.ps.gz</url>
      <publisher>Technical Report, Univ. Passau, Germany</publisher>
    </inproceedings>
  </entry>
  <entry id="loulergue_hains1998c">
    <techreport>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <title>{An Introduction to BS$\lambda$}</title>
      <institution>LIFO, Université d'Orléans</institution>
      <year>1998</year>
      <number>RR98-09</number>
      <abstract-url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/rr98-09_abstract.txt</abstract-url>
      <url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/rr98-09.ps.gz</url>
      <month>September</month>
    </techreport>
  </entry>
  <entry id="loulergue1999a">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{Extension du BS$\lambda$-calcul}</title>
      <booktitle>JFLA'99 : Journées Francophones des Langages Applicatifs</booktitle>
      <editor>Weiss, P.</editor>
      <address>Morzine-Avoriaz</address>
      <organization>INRIA</organization>
      <year>1999</year>
      <month>February</month>
      <abstract-url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/jfla99_abstract.txt</abstract-url>
      <url>ftp://ftp-lifo.univ-orleans.fr/pub/Users/loulergu/jfla99.ps.gz</url>
    </inproceedings>
  </entry>
  <entry id="truong98">
    <inproceedings>
      <author>Truong, Dan N.</author>
      <author>Bodin, Francois</author>
      <author>Seznec, Andre</author>
      <booktitle>Proceedings of the International Conference on Parallel Architectures and Compilation Techniques (PACT'98)</booktitle>
      <month>October</month>
      <title>Improving Locality of Dynamically Allocated Data Structures</title>
      <year>1998</year>
    </inproceedings>
  </entry>
  <entry id="pelikan:98a">
    <inproceedings>
      <author>Pelikan, Martin</author>
      <author>Goldberg, David E.</author>
      <author>Cantú-Paz, Erick</author>
      <title>{BOA}: The {B}ayesian Optimization Algorithm</title>
      <booktitle>Proceedings of the Genetic and Evolutionary Computation Conference GECCO-99</booktitle>
      <volume>I</volume>
      <pages>525-532</pages>
      <year>1999</year>
      <month>13-17 July</month>
      <editor>Banzhaf, Wolfgang</editor>
      <editor>Daida, Jason</editor>
      <editor>Eiben, Agoston E.</editor>
      <editor>Garzon, Max H.</editor>
      <editor>Honavar, Vasant</editor>
      <editor>Jakiela, Mark</editor>
      <editor>Smith, Robert E.</editor>
      <isbn>1-55860-611-4</isbn>
      <address>Orlando, FL</address>
      <publisher>Morgan Kaufmann Publishers, San Fransisco, CA</publisher>
      <keywords>linkage problem</keywords>
      <keywords>estimation of distribution algorithm</keywords>
      <keywords>learning Bayesian networks</keywords>
      <keywords>evolutionary computation</keywords>
      <keywords>genetic algorithm</keywords>
    </inproceedings>
  </entry>
  <entry id="cockshott93h">
    <article>
      <author>Cockshott, Paul</author>
      <title>Persistent objects in Turbo Pascal for Windows</title>
      <journal>Journal of Object Oriented Programming</journal>
      <number>2</number>
      <volume>6</volume>
      <year>1993</year>
    </article>
  </entry>
  <entry id="giavitto87b">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Holvoet, Y.</author>
      <author>Mauboussin, A.</author>
      <author>Pauthe, P.</author>
      <title>Guides lines for building adaptable browsing tools</title>
      <booktitle>{ESPRIT} Technical Week</booktitle>
      <year>1987</year>
      <optorganization>CEE</optorganization>
      <address>Brussel</address>
      <month>September</month>
    </inproceedings>
  </entry>
  <entry id="giavitto88a">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Devarenne, A.</author>
      <author>Rosuel, G.</author>
      <title>{PRESTO}: des objets {C++} persistants pour le système d'information d'{ADAGE}</title>
      <booktitle>Journées d'études Bases de données déductives et Bases de données orientées objets</booktitle>
      <year>1988</year>
      <organization>AFCET</organization>
      <address>Paris</address>
      <month>Décembre</month>
    </inproceedings>
  </entry>
  <entry id="giavitto89c">
    <techreport>
      <author>Giavitto, J.-L.</author>
      <author>Mauboussin, A.</author>
      <title>{PLUSS} algebraic specification of a subset of the {ADAGE} Data Description Language</title>
      <institution>{METEOR ESPRIT} Technical reports / {CEE}</institution>
      <year>1989</year>
      <number>t11/CGE/O1989</number>
      <month>October</month>
      <note>(44p.)</note>
    </techreport>
  </entry>
  <entry id="giavitto89d">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Devarenne, A.</author>
      <author>Rosuel, G.</author>
      <author>Y., Holvoet</author>
      <title>{ADAGE}: new trends in {CASE} environments</title>
      <booktitle>Proc. of the International Conference on System Development Environements \&amp; Factories</booktitle>
      <year>1989</year>
      <address>Berlin</address>
      <publisher>Pitman</publisher>
      <month>9-11 May</month>
    </inproceedings>
  </entry>
  <entry id="giavitto90">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Devarenne, A.</author>
      <author>Rosuel, G.</author>
      <author>Holvoet, Y.</author>
      <author>Mauboussin, A.</author>
      <title>Design decisions for the incremental ADAGE framework</title>
      <booktitle>cse90</booktitle>
      <month>March</month>
      <address>Nice</address>
      <year>1990</year>
    </inproceedings>
  </entry>
  <entry id="rosuel91">
    <inproceedings>
      <author>Rosuel, G.</author>
      <author>Giavitto, J.-L.</author>
      <author>Devarenne, A.</author>
      <title>The internals of a Large CASE tool in C++</title>
      <booktitle>Proc. of the 5th Int. Conf. on Technology of object-oriented languages and systems, TOOLS 5</booktitle>
      <address>Santa-Barbara, CA</address>
      <month>August</month>
      <year>1991</year>
      <publisher>Prentice Hall</publisher>
    </inproceedings>
  </entry>
  <entry id="cappello93a">
    <inproceedings>
      <author>Cappello, F.</author>
      <author>Béchennec, J.-L.</author>
      <author>Delaplace, F.</author>
      <author>Germain, C.</author>
      <author>Giavitto, J.-L.</author>
      <author>Neri, V.</author>
      <author>Etiemble, D.</author>
      <title>Balanced distributed memory parallel computers</title>
      <booktitle>Int. Conf. on Parallel Processing, St Charles, Ill.</booktitle>
      <publisher>CRC Press</publisher>
      <pages>72-76</pages>
      <year>1993</year>
    </inproceedings>
  </entry>
  <entry id="cappello94">
    <inproceedings>
      <author>Cappello, F.</author>
      <author>Béchennec, J.-L.</author>
      <author>Delaplace, D.</author>
      <author>Germain, C.</author>
      <author>Giavitto, J.-L.</author>
      <author>Neri, V.</author>
      <author>Etiemble, D.</author>
      <title>A parallel architecture based on compiled communication schemes</title>
      <booktitle>Parallel Computing: Trends and Applications (PARCO'94)</booktitle>
      <publisher>Elsevier</publisher>
      <editor>Joubert</editor>
      <editor>Trystram</editor>
      <editor>Peters</editor>
      <editor>Evans</editor>
      <year>1994</year>
      <pages>371-378</pages>
    </inproceedings>
  </entry>
  <entry id="delaplace91">
    <inproceedings>
      <author>Delaplace, F.</author>
      <author>Giavitto, J.-L.</author>
      <title>An efficient routing strategy to support process migration</title>
      <booktitle>Euromicro 91, Vienne, Autriche</booktitle>
      <year>1991</year>
    </inproceedings>
  </entry>
  <entry id="germain90c">
    <inproceedings>
      <author>Germain, C.</author>
      <author>Giavitto, J.-L.</author>
      <title>A comparaison of two routing strategies for massively parallel computers</title>
      <booktitle>5th Int. Symp. on Computer and Information Sciences, Cappadocia, Turquie</booktitle>
      <year>1990</year>
    </inproceedings>
  </entry>
  <entry id="giavitto91b">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <title>A synchronous data-flow language for massively parallel computer</title>
      <booktitle>Proc. of Int. Conf. on Parallel Computing (ParCo'91)</booktitle>
      <editor>Evans, D. J.</editor>
      <editor>Joubert, G. R.</editor>
      <editor>Liddell, H.</editor>
      <year>1991</year>
      <publisher>North-Holland</publisher>
      <address>London</address>
      <month>3-6 September</month>
      <pages>391-397</pages>
    </inproceedings>
  </entry>
  <entry id="giavitto91c">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Germain, C.</author>
      <author>Fowler, J.</author>
      <title>{OAL}: an implementation of an actor language on a massively parallel Message-Passing Architecture</title>
      <booktitle>2nd European Distributed Memory Computing Conf. (EDMCC2)</booktitle>
      <volume>492</volume>
      <series>LNCS</series>
      <year>1991</year>
      <publisher>Springer-Verlag</publisher>
      <address>Münich</address>
      <month>22-24 April</month>
    </inproceedings>
  </entry>
  <entry id="giavitto92a">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <title>Typing geometries of homogeneous collection</title>
      <booktitle>2nd Int. workshop on array manipulation, (ATABLE)</booktitle>
      <year>1992</year>
      <address>Montréal</address>
    </inproceedings>
  </entry>
  <entry id="giavitto92c">
    <conference>
      <author>Giavitto, J.-L.</author>
      <author>Sansonnet, J.-P.</author>
      <author>Michel, O.</author>
      <title>Inférer rapidement la géometrie des collections</title>
      <booktitle>Workshop on Static Analysis (WSA'92), Bordeaux</booktitle>
      <year>1992</year>
    </conference>
  </entry>
  <entry id="giavitto95">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Michel, O.</author>
      <author>Sansonnet, J.-P.</author>
      <title>Group based fields</title>
      <editor>Takayasu, I.</editor>
      <editor>Halstead, R. H. Jr.</editor>
      <editor>Queinnec, C.</editor>
      <volume>1068</volume>
      <series>LNCS</series>
      <pages>209-215</pages>
      <booktitle>Parallel Symbolic Languages and Systems (International Workshop PSLS'95)</booktitle>
      <year>1995</year>
      <publisher>Springer-Verlag</publisher>
      <address>Beaune (France)</address>
      <month>2-4 October</month>
    </inproceedings>
  </entry>
  <entry id="giavitto97a">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Vito, D. De</author>
      <author>Michel, O.</author>
      <title>Semantics and Compilation of Recursive Sequential Streams in 8{\footnotesize1/2}</title>
      <editor>Glaser, H.</editor>
      <editor>Kuchen, H.</editor>
      <volume>1292</volume>
      <series>LNCS</series>
      <pages>207-223</pages>
      <booktitle>Ninth International Symposium on Programming Languages, Implementations, Logics, and Programs (PLILP'97)</booktitle>
      <year>1997</year>
      <publisher>Springer-Verlag</publisher>
      <address>Southampton</address>
      <month>3-5 September</month>
    </inproceedings>
  </entry>
  <entry id="giavitto98b">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Vito, D. De</author>
      <author>Sansonnet, J.-P.</author>
      <title>A Data Parallel {Java} Client-Server Architecture for Data Field Computations over ${{\mathchoice {\hbox{$\sf\textstyle Z\kern-0.4em Z$}}{\hbox{$\sf\textstyle Z\kern-0.4em Z$}}{\hbox{$\sf\scriptstyle Z\kern-0.3em Z$}}{\hbox{$\sf\scriptscriptstyle Z\kern-0.2em Z$}}}}^{n}$</title>
      <booktitle>EuroPar'98 Parallel Processing</booktitle>
      <series>LNCS</series>
      <year>1998</year>
      <month>September</month>
      <adress>Southampton (United Kingdom)</adress>
    </inproceedings>
  </entry>
  <entry id="giavitto98d">
    <techreport>
      <author>Giavitto, Jean-Louis</author>
      <author>Valencia, Erika</author>
      <title>Combinatorial Algebraic Topology for Dagrammatic Reasoning</title>
      <institution>Laboratoire de Recherche en Informatique, Univ. d'Orsay (Paris, France)</institution>
      <year>1998</year>
      <month>April</month>
      <number>1165</number>
    </techreport>
  </entry>
  <entry id="giavitto98e">
    <inproceedings>
      <author>Giavitto, J.-L.</author>
      <author>Valencia, E.</author>
      <title>Modeling Diagrammatic Reasoning Tasks with a Topological Framework</title>
      <booktitle>Thinking with Diagrams'98</booktitle>
      <year>1998</year>
      <month>Aug</month>
      <address>Aberystwyth, Univ. of Wales, United Kingdom</address>
    </inproceedings>
  </entry>
  <entry id="michel98b">
    <inproceedings>
      <author>Michel, Olivier</author>
      <author>Giavitto, Jean-Louis</author>
      <title>A declarative data parallel programming language for simulations</title>
      <booktitle>Proc. of the Seventh International Colloquium on Numerical Analysis and Computer Science with Applications</booktitle>
      <year>1998</year>
      <address>Plovdiv, Bulgaria</address>
      <month>August</month>
    </inproceedings>
  </entry>
  <entry id="mahiout94b">
    <inproceedings>
      <author>Mahiout, A.</author>
      <author>Giavitto, J.-L.</author>
      <author>Sansonnet, J.-P.</author>
      <title>Distribution and scheduling data-parallel dataflow programs on massively parallel architectures</title>
      <booktitle>SMS-TPE'94: Software for Multiprocessors and Supercomputers</booktitle>
      <address>Moscow</address>
      <publisher>Office of Naval Research USA \&amp; Russian Basic Research Foundation</publisher>
      <month>September</month>
      <year>1994</year>
      <pages>380-389</pages>
    </inproceedings>
  </entry>
  <entry id="mahiout94c">
    <conference>
      <author>Mahiout, A.</author>
      <author>Giavitto, J.-L.</author>
      <title>Data-parallelism and Data-flow: automatic mapping and scheduling for implicit parallelism</title>
      <booktitle>Franco-British meeting on Data-parallel Languages and Compilers for portable parallel computing</booktitle>
      <address>Villeneuve d'Ascq, 20 avril</address>
      <year>1994</year>
    </conference>
  </entry>
  <entry id="michel94">
    <inproceedings>
      <author>Michel, O.</author>
      <author>Giavitto, J.-L.</author>
      <author>Sansonnet, J.-P.</author>
      <title>A data-parallel declarative language for the simulation of large dynamical systems and its compilation</title>
      <booktitle>SMS-TPE'94: Software for Multiprocessors and Supercomputers</booktitle>
      <address>Moscow, 21-23 September</address>
      <publisher>Office of Naval Research USA \&amp; Russian Basic Research Foundation</publisher>
      <year>1994</year>
      <pages>103-111</pages>
    </inproceedings>
  </entry>
  <entry id="michel94b">
    <inproceedings>
      <author>Michel, O.</author>
      <author>Giavitto, J.-L.</author>
      <title>Design and Implementation of a Declarative Data-parallel Language</title>
      <booktitle>post-ICLP'94 workshop W6 on Parallel and Data Parallel Execution of Logic Programs</booktitle>
      <address>S. Margherita Liguria, Italy</address>
      <publisher>Uppsala University, Computing Science Department</publisher>
      <year>1994</year>
      <month>June</month>
    </inproceedings>
  </entry>
  <entry id="valencia98a">
    <inproceedings>
      <author>Valencia, Erika</author>
      <author>Giavitto, Jean-Louis</author>
      <author>Sansonnet, Jean-Paul</author>
      <title>{ESQIMO}: Modelling Analogy with Topology</title>
      <editor>Ritter, Franck</editor>
      <editor>Young, Richard</editor>
      <pages>212-213</pages>
      <booktitle>Second European Conference on Cognitive Modelling (ECCM2)</booktitle>
      <year>1998</year>
      <publisher>Nottingham University Press</publisher>
      <address>Nottingham, UK</address>
      <month>1-4 April</month>
    </inproceedings>
  </entry>
  <entry id="fp">
    <inproceedings>
      <author>Kewley, John M.</author>
      <author>Boddy, Graham S.</author>
      <title>{The Use of Functional Programming in the Flagship System Software Kernel}</title>
      <institution>European Computer-Industry Research Centre GmbH</institution>
      <year>1989</year>
      <booktitle>Workshop on Complex Functional Systems: Proceedings</booktitle>
      <month>December</month>
      <editor>Dwelly, Andrew</editor>
      <editor>O'Donnell, John</editor>
      <editor>Hall, Cordelia</editor>
      <address>Munich, Germany</address>
      <pdf>http://www.cscs.ch/ kewley/pubs/fp.pdf</pdf>
      <ps>http://www.cscs.ch/ kewley/pubs/fp.ps.gz</ps>
      <location>Munich</location>
      <number>TR-HCI-15</number>
      <abstract>This paper describes how Functional Programming was used in the Flagship System Software Kernel and how Formal Methods were used to design code to run on the parallel Flagship Machine. This method has generated about 20k lines of code and has proved to be very effective and readily adopted by the team.</abstract>
    </inproceedings>
  </entry>
  <entry id="tec:annots">
    <techreport>
      <author>While, Lyndon</author>
      <author>Glynn, Kevin</author>
      <author>Kewley, John</author>
      <author>Watson, Paul</author>
      <author>Hayes, Sean</author>
      <title>{Annotations for Hope$^{+}$}</title>
      <institution>Imperial College</institution>
      <address>London, UK</address>
      <year>1988</year>
      <number>IC/FPR/PROG/1.1.1/5</number>
    </techreport>
  </entry>
  <entry id="touati_rapport_optirs">
    <techreport>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>Optimal Register Saturation in Superscalar and VLIW Codes</title>
      <institution>INRIA</institution>
      <year>2000</year>
      <type>Research Report</type>
      <month>November</month>
      <note>ftp.inria.fr/INRIA/Projects/a3/touati/optiRS.ps.gz</note>
    </techreport>
  </entry>
  <entry id="touatiequimax">
    <inproceedings>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>{EquiMax}: {A} New Formulation of Acyclic Scheduling Problem for {ILP} Processors</title>
      <booktitle>Interaction between Compilers and Computer Architectures</booktitle>
      <year>2001</year>
      <month>January</month>
      <publisher>Kluwer Academic Publishers</publisher>
    </inproceedings>
  </entry>
  <entry id="touaticc01">
    <inproceedings>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>Register Saturation in Superscalar and VLIW Codes</title>
      <booktitle>Proceedings of The International Conference on Compiler Construction</booktitle>
      <year>2001</year>
      <series>Lecture Notes in Computer Science</series>
      <month>April</month>
      <publisher>Springer-Verlag</publisher>
    </inproceedings>
  </entry>
  <entry id="yahav01">
    <inproceedings>
      <author>Yahav, Eran</author>
      <title>Verifying Safety Properties of Concurrent Java Programs using 3-valued Logic</title>
      <booktitle>{\em Principles of Programming Languages (POPL)}</booktitle>
      <year>2001</year>
      <note>Available from http://www.math.tau.ac.il/$\sim$yahave/popl01.ps</note>
    </inproceedings>
  </entry>
  <entry id="mock99:fdo">
    <inproceedings>
      <title>Calpa: A Tool for Automating Dynamic Compilation</title>
      <author>Mock, Markus</author>
      <author>Berryman, Mark</author>
      <author>Chambers, Craig</author>
      <author>Eggers, Susan J.</author>
      <booktitle>Proceedings of the 2nd Workshop on Feedback-Directed Optimization, FDO 99</booktitle>
      <month>November</month>
      <year>1999</year>
    </inproceedings>
  </entry>
  <entry id="micro33:calpa">
    <inproceedings>
      <author>Mock, Markus</author>
      <author>Chambers, Craig</author>
      <author>Eggers, Susan J.</author>
      <title>Automating Selective Dynamic Compilation</title>
      <pages>291-302</pages>
      <booktitle>Proceedings of the 33rd annual IEEE/ACM international symposium on Microarchitecture</booktitle>
      <month>December</month>
      <year>2000</year>
      <abstract>Selective dynamic compilation systems, typically driven by annotations that identify run-time constants, can achieve significant program speedups. However, manually inserting annotations is a tedious and time-consuming process that requires careful inspection of a program's static characteristics and run-time behavior and much trial and error in order to select the most beneficial annotations. Calpa is a system that generates annotations automatically for the DyC dynamic compiler. Calpa combines execution frequency and value profile information with a model of dynamic compilation cost and dynamically generated code benefit to choose run-time constants and other dynamic compilation strategies. For the programs tested so far, Calpa generates annotations of the same or better quality as those found by a human, but in a fraction of the time. The result was equal or-better program speedups from dynamic compilation, but without the need for programmer intervention.</abstract>
    </inproceedings>
  </entry>
  <entry id="lctes00">
    <inproceedings>
      <author>Corti, M.</author>
      <author>Brega, R.</author>
      <author>Gross, T.</author>
      <title>Approximation of Worst-Case Execution Time for Preemptive Multitasking Systems</title>
      <booktitle>Proceedings of the ACM SIGPLAN 2000 Workshop on Languages, Compilers, and Tools for Embedded Systems (LCTES'2000)</booktitle>
      <year>2000</year>
      <month>June</month>
      <address>Vancouver, Canada</address>
      <url>http://www.inf.ethz.ch/personal/corti/publications/lctes00.pdf</url>
      <abstract-url>http://www.inf.ethz.ch/personal/corti/publications/lctes00_abstract.txt</abstract-url>
    </inproceedings>
  </entry>
  <entry id="touatiscopes01">
    <inproceedings>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>{Maximizing for Reducing Register Need in Acyclic Schedules}</title>
      <booktitle>{Proceedings of 5th International Workshop on Software and Compilers for Embedded Systems, SCOPES}</booktitle>
      <year>2001</year>
      <address>{St Goar, Germany}</address>
      <month>March</month>
    </inproceedings>
  </entry>
  <entry id="touaticodes01">
    <inproceedings>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>{Optimal Acyclic Fine-Grain Schedule with Cache Effects for Embedded and Real Time Systems}</title>
      <booktitle>{Proceedings of 9th nternational Symposium on Hardware/Software Codesign, CODES}</booktitle>
      <year>2001</year>
      <address>{Copenhagen, Denmark}</address>
      <publisher>ACM</publisher>
      <month>April</month>
    </inproceedings>
  </entry>
  <entry id="atallah:2001">
    <article>
      <author>Atallah, M. J.</author>
      <title>On Estimating the Large Entries of a Convolution</title>
      <journal>IEEE Transactions on Computers</journal>
      <volume>50</volume>
      <number>3</number>
      <pages>193-196</pages>
      <month>March</month>
      <year>2001</year>
    </article>
  </entry>
  <entry id="tyan:2001">
    <article>
      <author>Tyan, H.-Y.</author>
      <author>Hou, J. C.</author>
      <author>Wang, B.</author>
      <author>Han, C.-C.</author>
      <title>On Supporting Temporal Quality of Service in WDMA-Based Star-Coupled Optical Networks</title>
      <journal>IEEE Transactions on Computers</journal>
      <volume>50</volume>
      <number>3</number>
      <pages>197-214</pages>
      <month>March</month>
      <year>2001</year>
    </article>
  </entry>
  <entry id="um:2001">
    <article>
      <author>Um, J.</author>
      <author>Kim, T.</author>
      <title>An Optimal Allocation of Carry-Save-Adders in Arithmetic Circuits</title>
      <journal>IEEE Transactions on Computers</journal>
      <volume>50</volume>
      <number>3</number>
      <pages>215-233</pages>
      <month>March</month>
      <year>2001</year>
    </article>
  </entry>
  <entry id="llosa:2001">
    <article>
      <author>Llosa, J.</author>
      <author>Ayguade, E.</author>
      <author>Gonzalez, A.</author>
      <author>Valero, M.</author>
      <author>Eckhardt, J.</author>
      <title>Lifetime-Sensitive Modulo Scheduling in a Production Environment</title>
      <journal>IEEE Transactions on Computers</journal>
      <volume>50</volume>
      <number>3</number>
      <pages>234-249</pages>
      <month>March</month>
      <year>2001</year>
      <keywords>fine grain parallelism</keywords>
      <keywords>instruction scheduling</keywords>
      <keywords>loop scheduling</keywords>
      <keywords>software pipelining</keywords>
      <keywords>register requirements</keywords>
      <keywords>VLIW</keywords>
      <keywords>superscalar architectures</keywords>
    </article>
  </entry>
  <entry id="haynal:2001">
    <article>
      <author>Haynal, S.</author>
      <author>Brewer, F.</author>
      <title>Automata-Based Symbolic Scheduling for Looping DFGs</title>
      <journal>IEEE Transactions on Computers</journal>
      <volume>50</volume>
      <number>3</number>
      <pages>250-267</pages>
      <month>March</month>
      <year>2001</year>
    </article>
  </entry>
  <entry id="zyuban:2001">
    <article>
      <author>Zyuban, V. V.</author>
      <author>Kogge, P. M.</author>
      <title>Inherently Lower-Power High-Performance Superscalar Architectures</title>
      <journal>IEEE Transactions on Computers</journal>
      <volume>50</volume>
      <number>3</number>
      <pages>268-285</pages>
      <month>March</month>
      <year>2001</year>
    </article>
  </entry>
  <entry id="su:esop01">
    <inproceedings>
      <author>Su, Zhendong</author>
      <author>Aiken, Alexander</author>
      <title>Entailment with Conditional Equality Constraints</title>
      <booktitle>Proceedings of European Symposium on Programming</booktitle>
      <year>2001</year>
      <month>April</month>
      <pages>170-189</pages>
    </inproceedings>
  </entry>
  <entry id="ucb//csd-00-1113">
    <techreport>
      <type>Technical Report</type>
      <number>CSD-00-1113</number>
      <institution>University of California, Berkeley</institution>
      <title>Entailment with Conditional Equality Constraints</title>
      <month>October</month>
      <year>2000</year>
      <author>Su, Zhendong</author>
      <author>Aiken, Alexander</author>
    </techreport>
  </entry>
  <entry id="didrichbstt2000">
    <inproceedings>
      <author>Didrich, Klaus</author>
      <author>Grieskamp, Wolfgang</author>
      <author>Schintke, Florian</author>
      <author>Tantau, Till</author>
      <author>Trancón-y-Widemann, Baltasar</author>
      <title>Reflections in Opal - Meta Information in a Functional Programming Language</title>
      <abstract>We report on an extension of the Opal system that allows the use of \emph{reflections}. Using reflections, a programmer can query information like the type of an object at runtime. The type can in turn be queried for properties like the constructor and deconstructor functions, and the resulting reflected functions can be evaluated. These facilities can be used for generic meta-programming. We describe the reflection interface of Opal and its applications, and sketch the implementation. For an existing language implementation like Opal's the extension by a reflection facility is challenging: in a statically typed language the management of \emph{runtime type information} seems to be an alien objective. However, it turns out that runtime type information can be incorporated in an elegant way by a source-level transformation and an appropriate set of library modules. We show how this transformation can be done without changing the Opal core system and causing runtime overhead only where reflections are actually used.</abstract>
      <booktitle>Proceedings of the 11th International Workshop on Implementation of Functional Languages, Lochem, The Netherlands, September 1999, (IFL'99), Selected Papers</booktitle>
      <editor>Koopman, P.</editor>
      <editor>Clack, C.</editor>
      <pages>149-164</pages>
      <series>Lecture Notes on Computer Science</series>
      <volume>1868</volume>
      <publisher>Springer</publisher>
      <year>2000</year>
    </inproceedings>
  </entry>
  <entry id="kind:98">
    <phdthesis>
      <author>Kind, A.</author>
      <title>An Architecture for Interpreted Dynamic Object-Oriented Languages</title>
      <school>University of Bath, School of Mathematical Sciences</school>
      <type>Dissertation</type>
      <year>1998</year>
      <url>http://www.maths.bath.ac.uk/jap/ak1/thesis.ps.gz</url>
      <abstract>This thesis is concerned with the implementation of object-oriented dynamic programming languages based on bytecode interpretation. A new interpretive implementation architecture is proposed that meets the requirements of code and system portability, execution performance, static and dynamic memory efficiency as well as language interoperability. The different quality of the architecture compared to other virtual machine approaches is related to the key techniques developed within this work: (i) C embedded virtual machine code, (ii) indexed code threading, (iii) optimal virtual instruction ordering and (iv) quasi-inline method caching. C embedded virtual machine code refers to the representation of bytecodes as constant C arrays that are located in sharable text segments after compilation. Interoperability, application start-up and dynamic memory usage benefit from this representation. Indexed code threading addresses the performance problem with virtual instruction mapping (i.e. loading, decoding and invoking) by using fast threaded instruction transfer. Unlike with standard code threading, virtual machine code remains compact and executable also with a non-threaded virtual machine emulator. A further performance boost is achieved with optimal virtual instruction ordering. This technique helps to cluster the native code implementing virtual instructions so that native instruction cache performance is increased. Finally, the efficiency problem involved with dynamic method lookup is alleviated with an inline caching scheme that is applicable with constant bytecode vectors. The scheme exploits type locality similar to polymorphic inline caching. However, dynamic memory is saved by avoiding redundant method entries and by being adaptable to generic function invocation which typically comes in waves with hot-spots on particular methods. A realization of the architecture is presented in form of an implementation of the dynamic object-oriented language EuLisp. The implementation demonstrates the feasibility and effectiveness of the proposed architecture. The average performance increase with indexed code threading is 14\% (P5) and 17\% (MIPS). The average increase with optimal instruction ordering in the indexed threaded interpreter is 21\% (P5) and 15\% (MIPS). Sharable read-only data is increased on average by a factor of two and finally, the miss ratio with quasi-inline method caching is measured as 1.06\%.</abstract>
    </phdthesis>
  </entry>
  <entry id="tangxue00">
    <article>
      <author>Tang, P.</author>
      <author>Xue, J.</author>
      <title>Generating Efficient Tiled Code for Distributed Memory Machines</title>
      <journal>Parallel Computing</journal>
      <volume>26</volume>
      <number>11</number>
      <pages>1369-1411</pages>
      <year>2000</year>
    </article>
  </entry>
  <entry id="ambler01preface">
    <inproceedings>
      <author>Crole, Roy L.</author>
      <author>Ambler, Simon J.</author>
      <author>Momigliano, Alberto</author>
      <title>Preface to Volume 58, Issue 1</title>
      <booktitle>Electronic Notes in Theoretical Computer Science</booktitle>
      <volume>58</volume>
      <issue>1</issue>
      <publisher>Elsevier Science Publishers</publisher>
      <editor>Crole, R. L.</editor>
      <editor>Ambler, S. J.</editor>
      <editor>Momigliano, A.</editor>
      <year>2001</year>
    </inproceedings>
  </entry>
  <entry id="touati_rapport_optirs">
    <techreport>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>{Optimal Register Saturation in Acyclic Superscalar and VLIW Codes}</title>
      <institution>{INRIA}</institution>
      <year>2001</year>
      <type>{Research Report}</type>
      <number>{RR-4263}</number>
      <month>September</month>
      <note>ftp.inria.fr/INRIA/publication/publi-ps-gz/RR/RR-4263.ps.gz</note>
    </techreport>
  </entry>
  <entry id="touaticpc01">
    <inproceedings>
      <author>Touati, Sid-Ahmed-Ali</author>
      <author>Eisenbeis, Christine</author>
      <title>Schedule Independent Register Allocation for Software Pipelining</title>
      <year>2001</year>
      <booktitle>9th Workshop on Compilers for Parallel Computers</booktitle>
      <address>Edinburgh, Scotland, UK</address>
      <month>June</month>
      <note>ftp://ftp.inria.fr/INRIA/Projects/a3/touati/touati_cpc01.ps.gz</note>
    </inproceedings>
  </entry>
  <entry id="zw01b">
    <inproceedings>
      <author>Zeitlhofer, T.</author>
      <author>Wess, B.</author>
      <title>Integrated Scheduling and Register Assignment for VLIW-DSP Architectures</title>
      <booktitle>Proceedings of the 14th IEEE International ASIC/SOC Conference</booktitle>
      <year>2001</year>
      <address>Washington DC, USA</address>
      <month>September</month>
    </inproceedings>
  </entry>
  <entry id="vildarib2001a">
    <incollection>
      <author>Vilares, M.</author>
      <author>Darriba, V. M.</author>
      <author>Ribadas, F. J.</author>
      <title>Regional Least-Cost Error Repair</title>
      <booktitle>Implementation and Application of Automata</booktitle>
      <publisher>Springer-Verlag</publisher>
      <year>2001</year>
      <editor>Yu, S.</editor>
      <editor>P{\u{a}}un, A.</editor>
      <volume>2088</volume>
      <series>Lecture Notes in Artificial Intelligence</series>
      <pages>293-303</pages>
      <address>Berlin-Heidelberg-New York</address>
    </incollection>
  </entry>
  <entry id="zobel:phd">
    <phdthesis>
      <author>Zobel, Angelika</author>
      <title>{Program Structure as a Basis for the Parallelization of Global Compiler Optimizations}</title>
      <school>{Carnegie Mellon}</school>
      <year>1992</year>
      <month>May</month>
      <number>{CMU-CS-92-137}</number>
    </phdthesis>
  </entry>
  <entry id="kirner:ecrts01">
    <inproceedings>
      <author>Kirner, R.</author>
      <author>Puschner, P.</author>
      <title>Transformation of Path Information for WCET Analysis during Compilation</title>
      <booktitle>Proceedings of the 13th Euromicro Conference on Real-Time Systems</booktitle>
      <year>2001</year>
      <organization>Technical University of Delft</organization>
      <publisher>IEEE</publisher>
      <address>Delft, The Netherlands</address>
      <month>June</month>
      <pages>29-36</pages>
    </inproceedings>
  </entry>
  <entry id="roeckl01first-order">
    <inproceedings>
      <author>Roeckl, Christine</author>
      <title>A First-Order Syntax for the Pi-Calculus in Isabelle/HOL using Permutations</title>
      <booktitle>Electronic Notes in Theoretical Computer Science</booktitle>
      <volume>58</volume>
      <issue>1</issue>
      <publisher>Elsevier Science Publishers</publisher>
      <editor>, R. L. Crole S.J. Ambler</editor>
      <editor>Momigliano, A.</editor>
      <year>2001</year>
    </inproceedings>
  </entry>
  <entry id="hindpioli97">
    <techreport>
      <author>Hind, Michael</author>
      <author>Pioli, Anthony</author>
      <title>An Empirical Comparison of Interprocedural Pointer Alias Analyses</title>
      <institution>T.J. Watson Research Center</institution>
      <year>1997</year>
      <type>IBM Research Report</type>
      <number>RC21058</number>
      <address>Yorktown Heights, New York</address>
      <month>December</month>
      <note>Superseded by SAS98-Paper.</note>
      <annote>The paper compares three interprocedural pointer alias analyses w.r.t. their precision and execution speed. All analyses represent the program as a call multi-graph (PCG), in which a node corresponds to a function, and a directed edge represents a call to the target function. Each function body is represented by a control flow graph. All analyses compute their solution using a nested fixed point computation, use a compact representation to represent alias relations and are context-insensitive. One analysis is flow-sensitive (FS), one is flow-insensitive (FI) and the last one is flow-insensitive and tries to precompute kill information for pointers (FIK). The benchmark suite contains fourteen C programs. All analyses are implemented using worklist algorithms and Dakota as intermediate representation. The results show that FIK is never more precise than FI, but on some occasions requires more analysis time than FS. In half of the benchmarks FI is as precise as FS. Although FI can be up to 4 times faster than FS, in one benchmark it was slower. Another conclusion is that analysis time does depend on the amount of alias relation propagation during analysis and not only on program size. The article describes efficiency improvements for the implementations and offers explanations for the results of the experiment.</annote>
    </techreport>
  </entry>
  <entry id="jfla02">
    <inproceedings>
      <author>Julien Cohen Olivier Michel, Jean-Louis Giavitto</author>
      <title>{MGS} : transformer des collections complexes pour la simulation en biologie</title>
      <booktitle>Journées Francophones des Langages Applicatifs</booktitle>
      <year>2002</year>
    </inproceedings>
  </entry>
  <entry id="jfla02">
    <inproceedings>
      <author>Julien Cohen Olivier Michel, Jean-Louis Giavitto</author>
      <title>{MGS} : transformer des collections complexes pour la simulation en biologie</title>
      <booktitle>Journées Francophones des Langages Applicatifs</booktitle>
      <year>2002</year>
      <url>http://www.lami.univ-evry.fr/mgs/PUBLICATIONS/mgsjfla02.ps.gz</url>
    </inproceedings>
  </entry>
  <entry id="ccm_isos">
    <inproceedings>
      <author>Cáccamo, Mario José</author>
      <author>Crazzolara, Federico</author>
      <author>Milicia, Giuseppe</author>
      <title>The {ISO} 5-pass authentication in $\chi $-{S}paces</title>
      <booktitle>Proceedings of the Security and Management Conference (SAM'02)</booktitle>
      <year>2002</year>
      <editor>Mun, Youngsong</editor>
      <editor>Arabnia, Hamid R.</editor>
      <pages>490-495</pages>
      <address>Las Vegas, Nevada, USA</address>
      <month>June</month>
      <publisher>CSREA Press</publisher>
      <keywords>Security Protocols</keywords>
      <keywords>formal verification</keywords>
      <keywords>programming languages</keywords>
      <url>http://www.chispaces.com/papers/isofinal.ps</url>
    </inproceedings>
  </entry>
  <entry id="touatiphd">
    <phdthesis>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>Register Pressure in Instruction Level Parallelism</title>
      <school>Université de Versailles</school>
      <year>2002</year>
      <address>Versailles, France</address>
      <month>June</month>
      <note>ftp.inria.fr/INRIA/Projects/a3/touati/thesis</note>
    </phdthesis>
  </entry>
  <entry id="brics-ep-02-mil_s">
    <inproceedings>
      <author>Milicia, Giuseppe</author>
      <title>$\chi$-Spaces: Programming Security Protocols</title>
      <booktitle>Prooceedings of the 14th Nordic Worskshop on Programming Theory (NWPT)</booktitle>
      <year>2002</year>
      <editor>Vain, Tarmo Uustalu Juri</editor>
      <pages>75-78</pages>
      <address>Tallin, Estonia</address>
      <month>November</month>
      <comment>Abstract</comment>
      <url>http://www.chispaces.com/papers/chispacesabstract.ps</url>
    </inproceedings>
  </entry>
  <entry id="moreaurv-ldta2001">
    <inproceedings>
      <author>Moreau, Pierre-Etienne</author>
      <author>Ringeissen, Christophe</author>
      <author>Vittek, Marian</author>
      <title>A Pattern-Matching Compiler</title>
      <year>2001</year>
      <booktitle>Proceedings of the 1st International Workshop on Language Descriptions, Tools and Applications</booktitle>
      <editor>Parigot, Didier</editor>
      <editor>van den Brand, Mark G. J.</editor>
      <publisher>Electronic Notes in Theoretical Computer Science</publisher>
      <volume>44</volume>
      <address>Genova (Italy)</address>
      <month>April</month>
    </inproceedings>
  </entry>
  <entry id="yrs01">
    <techreport>
      <author>Yahav, E.</author>
      <author>Reps, T.</author>
      <author>Sagiv, M.</author>
      <title>{LTL} Model Checking for Systems with Unbounded Number of Dynamically Created Threads and Objects</title>
      <institution>Computer Sciences Department, University of Wisconsin, Madison, WI</institution>
      <year>2001</year>
      <number>TR-1424</number>
      <month>March</month>
    </techreport>
  </entry>
  <entry id="yrsr02">
    <techreport>
      <author>Yahav, E.</author>
      <author>Reps, T.</author>
      <author>Sagiv, M.</author>
      <author>Wilhelm, R.</author>
      <title>Automatic Verification of Temporal Properties of Concurrent Heap-Manipulating Programs using Evolution Logic</title>
      <institution>School of Computer Science, Tel Aviv University, Israel</institution>
      <year>2002</year>
      <number>TR-338/02</number>
      <month>July</month>
      <note>revised version to appear in ESOP03</note>
    </techreport>
  </entry>
  <entry id="momigliano02hybrid">
    <inproceedings>
      <author>Momigliano, Simon J. Ambler Alberto</author>
      <author>Crole, Roy L.</author>
      <title>A Hybrid Encoding of Howe's Method for Establishing Congruence of Bisimilarity</title>
      <booktitle>Electronic Notes in Theoretical Computer Science</booktitle>
      <volume>70</volume>
      <issue>2</issue>
      <publisher>Elsevier Science Publishers</publisher>
      <editor>Pfenning, Frank</editor>
      <year>2002</year>
    </inproceedings>
  </entry>
  <entry id="voigtlaender:icfp:2002">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Concatenate, Reverse and Map Vanish For Free</title>
      <editor>Jones, Simon Peyton</editor>
      <booktitle>International Conference on Functional Programming, Pittsburgh, Pennsylvania, Proceedings</booktitle>
      <year>2002</year>
      <month>October 4-6</month>
      <series>ACM SIGPLAN Notices</series>
      <volume>37</volume>
      <publisher>ACM Press</publisher>
      <pages>14-25</pages>
      <abstract>We introduce a new transformation method to eliminate intermediate data structures occurring in functional programs due to repeated list concatenations and other data manipulations (additionally exemplified with list reversal and mapping of functions over lists). The general idea is to uniformly abstract from data constructors and manipulating operations by means of rank-2 polymorphic combinators that exploit algebraic properties of these operations to provide an optimized implementation. The correctness of transformations is proved by using the free theorems derivable from parametric polymorphic types.</abstract>
      <keywords>combinators</keywords>
      <keywords>correctness proofs</keywords>
      <keywords>denotational semantics</keywords>
      <keywords>list abstraction</keywords>
      <keywords>parametricity</keywords>
      <keywords>program transformation</keywords>
      <keywords>rank-2 types</keywords>
      <keywords>shortcut deforestation</keywords>
      <keywords>the concatenate vanishes</keywords>
      <keywords>theorems for free</keywords>
      <url>http://doi.acm.org/10.1145/581478.581481</url>
    </inproceedings>
  </entry>
  <entry id="voigtlaender:asia-pepm:2002">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Using Circular Programs to Deforest in Accumulating Parameters</title>
      <editor>Chin, Wei-Ngan</editor>
      <booktitle>Asian Symposium on Partial Evaluation and Semantics-Based Program Manipulation, Aizu, Japan, Proceedings</booktitle>
      <year>2002</year>
      <month>September 12-14</month>
      <publisher>ACM Press</publisher>
      <pages>126-137</pages>
      <abstract>Functional languages allow a modular programming style by function composition, which however can lead to inefficient runtime behavior due to production and consumption of intermediate results. We present a new mechanizable transformation technique for removing intermediate data structures in the composition of two functions from a class of recursive functions with accumulating parameters, for which classical deforestation techniques fail. In order to avoid multiple traversals of the input data structure, the composition algorithm produces circular programs that make essential use of lazy evaluation and local recursion. The resulting programs are simplified using a post-processing phase presented in the paper.</abstract>
      <keywords>accumulating parameters</keywords>
      <keywords>circular programs</keywords>
      <keywords>deforestation</keywords>
      <keywords>intermediate data structures</keywords>
      <keywords>lazy composition</keywords>
      <keywords>lazy evaluation</keywords>
      <keywords>multiple traversals</keywords>
      <keywords>program transformation</keywords>
      <keywords>tupling</keywords>
      <url>http://doi.acm.org/10.1145/568173.568187</url>
    </inproceedings>
  </entry>
  <entry id="touati_eisenbeis:cc03">
    <inproceedings>
      <author>Touati, Sid-Ahmed-Ali</author>
      <author>Eisenbeis, Christine</author>
      <title>Early Control of Register Pressure for Software Pipelined Loops</title>
      <booktitle>International Conference on Compiler Construction</booktitle>
      <year>2003</year>
      <editor>Hedin, Görel</editor>
      <series>Lecture Notes in Computer Science</series>
      <address>Warsaw, Poland</address>
      <optmonth>April</optmonth>
      <publisher>Springer-Verlag</publisher>
    </inproceedings>
  </entry>
  <entry id="touati:cpc03:b">
    <inproceedings>
      <author>Touati, Sid-Ahmed-Ali</author>
      <title>Minimizing Register Requirement in Loop Data Dependence Graphs</title>
      <booktitle>Compilers for Parallel Computers</booktitle>
      <year>2003</year>
      <address>Amsterdam, The Netherlands</address>
      <month>January</month>
    </inproceedings>
  </entry>
  <entry id="ds91">
    <article>
      <author>Dave, Maulik A.</author>
      <author>Srikant, Y. N.</author>
      <title>A Parallelizing Compiler for Pascal</title>
      <journal>The Journal of Indian Institute of Science</journal>
      <year>1991</year>
    </article>
  </entry>
  <entry id="marintepeneu:2003">
    <inproceedings>
      <author>Marin, Mircea</author>
      <author>Tepeneu, Dorin</author>
      <title>{P}rogramming with {S}equence {V}ariables: {T}he {S}equentica {P}ackage</title>
      <booktitle>{Challenging the Boundaries of Symbolic Computation. Proceedings of 5th International Mathematica Symposium (IMS 2003)}</booktitle>
      <editor>Mitic, Peter</editor>
      <editor>Ramsden, Philip</editor>
      <editor>Carne, Janet</editor>
      <publisher>Imperial College Press</publisher>
      <month>July 7-11</month>
      <year>2003</year>
      <pages>17-24</pages>
      <address>Imperial College, London</address>
    </inproceedings>
  </entry>
  <entry id="mm-rdp03">
    <inproceedings>
      <author>Marin, Mircea</author>
      <title>Functional Programming with Sequence Variables: The Sequentica Package</title>
      <booktitle>Proceedings of the 17th International Workshop on Unification (UNIF 2003)</booktitle>
      <editor>Levy, J.</editor>
      <editor>Kohlhase, M.</editor>
      <editor>Niehren, J.</editor>
      <editor>Villaret, M.</editor>
      <address>Valencia</address>
      <pages>65-78</pages>
      <year>2003</year>
    </inproceedings>
  </entry>
  <entry id="sedaaghi:2003-2">
    <inproceedings>
      <author>Sedaaghi, M. H.</author>
      <author>Ajami, E.</author>
      <title>Adaptive color image denoising using neural networks</title>
      <editor>Leung, H.</editor>
      <booktitle>Proceedings of the 7th. IASTED International Conference, Artificial Intelligence and Soft Computing, Jul. 14-16, 2003</booktitle>
      <year>2003</year>
      <publisher>IASTED</publisher>
      <address>Banff, Canada</address>
      <pages>1-5</pages>
    </inproceedings>
  </entry>
  <entry id="lou2003:parco">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{A Calculus of Functional BSP Programs with Explicit Substitution}</title>
      <booktitle>ParCo 2003</booktitle>
      <address>Dresden, Germany</address>
      <month>September</month>
      <note>to appear</note>
      <year>2003</year>
      <abstract>The BSlambdasigmaUparrow-calculus calculus is a calculus of functional BSP programs with enumerated parallel vectors and explicit substitution. This confluent calculus is defined and proved confluent. These results constitute the core of a formal design for a Bulk Synchronous Parallel dialect of ML (BSML) as well as a framework for proving parallel abstract machine which can evaluate BSML programs.</abstract>
    </inproceedings>
  </entry>
  <entry id="gl2003:parco">
    <inproceedings>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <title>{Semantics of a Functional Bulk Synchronous Parallel Language with Imperative Features}</title>
      <booktitle>ParCo 2003</booktitle>
      <address>Dresden, Germany</address>
      <month>September</month>
      <note>to appear</note>
      <year>2003</year>
      <abstract>The Bulk Synchronous Parallel ML (BSML) is a functional language for Bulk Synchronous Parallel (BSP) programming, on top of the sequential functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. The Objective Caml language is a functional language but it also offers imperative features. This paper presents formal semantics of BSML with references, assignment and dereferencing.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou2003:parcob">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{A Event Oriented Functional Parallel Language}</title>
      <booktitle>ParCo 2003</booktitle>
      <address>Dresden, Germany</address>
      <month>September</month>
      <note>to appear</note>
      <year>2003</year>
      <abstract>This paper presents the design of the core of a parallel programming language called CDS*. It is based on explicitly-distributed concrete data structures and features compositional semantics, higher-order functions and explicitly distributed objects. The denotational semantics is outlined, the (equivalent) operational semantics is presented and a new realization of the latter is given as a rewriting system. Simulated execution of examples illustrates the language's flexibility and explicit control of data layout on the parallel network.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou2003:europar">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{Parallel Juxtaposition for Bulk Synchronous Parallel ML}</title>
      <booktitle>{Euro-Par 2003}</booktitle>
      <year>2003</year>
      <editor>Kosch, Harald</editor>
      <series>LNCS</series>
      <publisher>Springer Verlag</publisher>
      <note>to appear</note>
      <abstract>The BSMLlib library is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector. An attempt to add a parallel composition to this approach led to a non-confluent calculus and to a restricted form of parallel composition. This paper presents a new, simpler and more general semantics for parallel composition, renamed here parallel juxtaposition, as well as an associated cost model derived from the BSP cost model.</abstract>
    </inproceedings>
  </entry>
  <entry id="gl2003:pact">
    <inproceedings>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <title>{A Polymorphic Type System for Bulk Synchronous Parallel ML}</title>
      <year>2003</year>
      <booktitle>Seventh International Conference on Parallel Computing Technologies (PaCT 2003)</booktitle>
      <series>LNCS</series>
      <publisher>Springer Verlag</publisher>
      <note>to appear</note>
      <abstract>The BSMLlib library is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a data structure named parallel vector, which is given by intention. In order to have an execution that follows the BSP model, and to have a simple cost model, nesting of parallel vectors is not allowed. The novelty of this paper is a type system which prevents such nesting. This system is correct w.r.t.\ the dynamic semantics which is also presented.</abstract>
    </inproceedings>
  </entry>
  <entry id="tr-2003-02">
    <techreport>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <title>{Verifying Functional Bulk Synchronous Parallel Programs Using the Coq System}</title>
      <year>2003</year>
      <institution>University of Paris 12, LACL</institution>
      <number>2003-02</number>
      <file>publications/TR-2003-02.pdf</file>
      <abstract>The Bulk Synchronous Parallel ML (BSML) is a functional language for Bulk Synchronous Parallel (BSP) programming. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. We present the formal proofs of correctness of BSML programs in the Coq proof assistant. Such development demonstrates the usefulness of higher-order logic in the process of software certification and parallel applications. They also show that proof of rather complex parallel algorithms may be made with inductive types by using the certified programs.</abstract>
    </techreport>
  </entry>
  <entry id="lou2003:iccs">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{Parallel Superposition for Bulk Synchronous Parallel ML}</title>
      <booktitle>International Conference on Computational Science (ICCS 2003), Part III</booktitle>
      <year>2003</year>
      <month>June</month>
      <publisher>Springer Verlag</publisher>
      <series>LNCS</series>
      <editor>Sloot, Peter M. A.</editor>
      <editor>al.</editor>
      <number>2659</number>
      <page>223-232</page>
      <abstract>The {\tt BSMLlib} library is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. Those operations are {\em flat} and allow BSP programming in direct mode but it is impossible to express directly divide-and-conquer algorithms. This paper presents a new construction for the {\tt BSMLlib} library which can express divide-and-conquer algorithms. It is called parallel superposition because it can be seen as the parallel composition of two BSP threads which can each use all the processors. An associated cost model derived from the BSP cost model is also given.</abstract>
    </inproceedings>
  </entry>
  <entry id="gl2003:iccs">
    <inproceedings>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <title>{A Parallel Virtual Machine for Bulk Synchronous Parallel ML}</title>
      <booktitle>International Conference on Computational Science (ICCS 2003), Part I</booktitle>
      <year>2003</year>
      <month>June</month>
      <publisher>Springer Verlag</publisher>
      <series>LNCS</series>
      <editor>Sloot, Peter M. A.</editor>
      <editor>al.</editor>
      <number>2657</number>
      <page>155-164</page>
      <abstract>We have designed a functional data-parallel language called BSML for programming bulk-synchronous parallel (BSP) algorithms in so-called direct mode. In a direct-mode BSP algorithm, the physical structure of processes is made explicit. The execution time can then be estimated and dead-locks and indeterminism are avoided. The BSMLlib library has been implemented for the Objective Caml language. But there is currently no full implementation of such a language and an abstract machine is needed to validate such an implementation. Our approach is based on a bytecode compilation to a parallel abstract machine performing exchange of data and synchronous requests derived from the ZAM, the efficient abstract machine of the Objective Caml language.</abstract>
    </inproceedings>
  </entry>
  <entry id="tr-2003-01">
    <techreport>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <title>{A Parallel Virtual Machine for Bulk Synchronous Parallel ML}</title>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2003</year>
      <month>January</month>
      <number>2003-01</number>
      <abstract>We have designed a functional data-parallel language called BSML for programming bulk-synchronous parallel (BSP) algorithms in so-called direct mode. In a direct-mode BSP algorithm, the physical structure of processes is made explicit. The execution time can then be estimated and dead-locks and indeterminism are avoided. The BSMLlib library has been implemented for the Objective Caml language. But there is currently no full implementation of such a language and an abstract machine is needed to validate such an implementation. Our approach is based on a bytecode compilation to a parallel abstract machine performing exchange of data and synchronous requests derived from the ZAM, the efficient abstract machine of the Objective Caml language.</abstract>
    </techreport>
  </entry>
  <entry id="tr-2002-21">
    <techreport>
      <author>Loulergue, F.</author>
      <title>{Compositionality in Functional Bulk Synchronous Parallelism}</title>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2002</year>
      <month>December</month>
      <number>2002-21</number>
      <abstract>The BS$\lambda_p$-calculs an extension of the $\lambda$-calculus by bulk synchronous parallel (BSP) operations on a parallel data structure named parallel vector. This paper presents how functional composition is preserved in this framework both from the semantics point of view and from the cost model point of view. Those operations are {\em flat} and allow BSP programming in direct mode but it is impossible to express directly divide-and-conquer algorithms. This paper also present a new kind of composition, a new construction for the BS$\lambda_p$-calculus which can express divide-and-conquer algorithms. It is called parallel superposition. An associated cost model derived from the BSP cost model is also given.</abstract>
    </techreport>
  </entry>
  <entry id="tr-2002-20">
    <techreport>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <title>{A Bulk Synchronous Parallel Categorical Abstract Machine}</title>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2002</year>
      <month>December</month>
      <number>2002-20</number>
      <abstract>We have designed a functional data-parallel language called BSML for programming bulk-synchronous parallel (BSP) algorithms in so-called direct mode. In a direct-mode BSP algorithm, the physical structure of processes is made explicit. The execution time can then be estimated and dead-locks and indeterminism are avoided. The \BSMLlib{} library has been implemented for the Objective Caml language. But there is currently no full implementation of such a language and an abstract machine is needed to validate such an implementation. Our approach is based on a natural semantics and a bytecode compilation to a parallel abstract machine performing exchange of data and synchronous requests derived from the abstract machine of the Caml language.</abstract>
    </techreport>
  </entry>
  <entry id="dl2003:pdcn">
    <inproceedings>
      <author>Dabrowski, F.</author>
      <author>Loulergue, F.</author>
      <title>{Functional Bulk Synchronous Programming in C++}</title>
      <booktitle>$21$st IASTED International Multi-conference, Applied Informatics (AI 2003), Symposium on Parallel and Distributed Computing and Networks</booktitle>
      <publisher>ACTA Press</publisher>
      <month>February</month>
      <year>2003</year>
      <pages>462-467</pages>
      <abstract>This paper presents the BSFC++ library for functional bulk synchronous parallel programming in C++. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. This guarantees the determinism and the absence of deadlock. Broadcast algorithms are implemented using the core library.</abstract>
    </inproceedings>
  </entry>
  <entry id="tr-2002-17">
    <techreport>
      <author>Loulergue, F.</author>
      <title>{Parallel Juxtaposition for Bulk Synchronous Parallel ML}</title>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2002</year>
      <month>November</month>
      <number>2002-17</number>
      <abstract>The BSMLlib is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. An attempt to add a parallel composition to this approach led to a non-confluent calculus and to a restricted form of parallel composition. This paper presents a new, simpler and more general semantics for parallel composition, renamed here parallel juxtaposition, as well as an associated cost model derived from the BSP cost model.</abstract>
    </techreport>
  </entry>
  <entry id="tr-2002-14">
    <techreport>
      <title>{Semantics of a Functional Bulk Synchronous Parallel Language with Imperative Features}</title>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2002</year>
      <month>October</month>
      <number>2002-14</number>
      <abstract>The Bulk Synchronous Parallel ML (BSML) is a functional language for Bulk Synchronous Parallel (BSP) programming, based on the sequential functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. The Objective Caml language is a functional language but it also offers imperative features. This paper presents formal semantics of BSML with references, affectation and dereferencing.</abstract>
    </techreport>
  </entry>
  <entry id="gl2003:jfla">
    <inproceedings>
      <author>Gava, F.</author>
      <author>Loulergue, F.</author>
      <title>{Synthèse de types pour Bulk Synchronous Parallel ML}</title>
      <booktitle>Journées Francophones des Langages Applicatifs (JFLA 2003)</booktitle>
      <institution>INRIA</institution>
      <year>2003</year>
      <month>January</month>
      <abstract>The BSMLlib library is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a data structure named parallel vector, which is given by intention. In order to have an execution that follows the BSP model, and to have a simple cost model, nesting of parallel vectors is not allowed. The novelty of this paper is a type system which prevents such nesting. An algorithm for type inference is also presented.</abstract>
    </inproceedings>
  </entry>
  <entry id="hl2002:cmppbook">
    <incollection>
      <author>Hains, G.</author>
      <author>Loulergue, F.</author>
      <title>{Functional Bulk Synchronous Parallel Programming using the BSMLlib Library}</title>
      <booktitle>Constructive Methods for Parallel Programming</booktitle>
      <publisher>Nova Science Publishers</publisher>
      <month>August</month>
      <year>2002</year>
      <editor>Gorlatch, S.</editor>
      <editor>Lengauer, C.</editor>
      <pages>165-178</pages>
      <series>Advances in Computation: Theory and Practice</series>
      <abstract>BSMLlib is a functional data-parallel library for programming bulk-synchronous parallel (BSP) algorithms in Objective CAML. The definition of BSMLlib and performance prediction for elementary operations have been discussed in \cite{sfp99}. This article demonstrates the expressivity of BSMLlib operations on elementary algorithms. Other operations, on a type of parallel sets, illustrate how BSP exchange phases are written as small, simple programs. A longer example, inspired by parallel join algorithms for relational databases, demonstrates the advantage of using BSMLlib's explicit processes for dynamic load balancing. Finally, suggestions are made for extending the library and building a complete BSML language with the same operations.</abstract>
    </incollection>
  </entry>
  <entry id="lou2002:pdcs">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{Implementation of a Functional Bulk Synchronous Parallel Programming Library}</title>
      <booktitle>$14$th IASTED International Conference on Parallel and Distributed Computing Systems</booktitle>
      <year>2002</year>
      <pages>452-457</pages>
      <publisher>ACTA Press</publisher>
      <abstract>The BSMLlib is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the lambda-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. A first implementation of this library was based on the BSPlib library, which is not longer supported nor updated. Being the basis of a framework for Grid computing, a new implementation of the BSMLlib based on MPI has been designed. Experimental results on a cluster of PCs are presented.</abstract>
    </inproceedings>
  </entry>
  <entry id="mhl2001:sfp">
    <inproceedings>
      <author>Merlin, A.</author>
      <author>Hains, G.</author>
      <author>Loulergue, F.</author>
      <title>{A SPMD Environment Machine for Functional BSP Programs}</title>
      <booktitle>Proceedings of the Third Scottish Functional Programming Workshop</booktitle>
      <year>2001</year>
      <month>August</month>
      <abstract>A functional data-parallel language called BSML has been designed for programming bulk-synchronous parallel (BSP) algorithms in so-called direct mode. Its aim is to offer predictable and scalable performance for BSP algorithms written as functional programs. The current implementation of BSML is a library and has not been validated w.r.t the language's formal definition. As a library, it does not allow static tools to support performance management. As a first step in the construction of a complete BSML language, we have defined a parallel environment machine from our language's evaluation semantics and begun testing the scalability and predictability of its performance. This paper presents the machine design and the results of our experiments.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou2001:sfpbook">
    <incollection>
      <author>Loulergue, F.</author>
      <editor>Gilmore, S.</editor>
      <booktitle>{Trends in Functional Programming, Volume 2}</booktitle>
      <title>{Parallel Composition and Bulk Synchronous Parallel Functional Programming}</title>
      <publisher>Intellect Books</publisher>
      <year>2001</year>
      <pages>77-88</pages>
      <abstract>The work described here is part of our research program to investigate new paradigms for declarative parallel programming through special interpretations of standard semantics. Our approach is a purely functional approach to programming of BSP algorithms. An attempt to add a parallel composition to this approach led to a non-confluent calculus. This paper presents a solution for adding the parallel composition to the weak call-by-value strategy of the BSlambda_p and to the BSMLlib library.</abstract>
    </incollection>
  </entry>
  <entry id="lou2001:ppl">
    <article>
      <author>Loulergue, F.</author>
      <title>{Distributed Evaluation of Functional BSP Programs}</title>
      <journal>Parallel Processing Letters</journal>
      <year>2001</year>
      <pages>423-437</pages>
      <number>4</number>
      <abstract>The BSlambda_p-calculus is a calculus of functional bulk synchronous parallel (BSP) programs. It is the basis for the design of a bulk synchronous parallel ML language. For data-parallel languages, there are two points of view: the programming model where a program is seen as a sequence of operations on parallel vectors, and the execution model where the program is a parallel composition of programs run on each processor of the parallel machine. BSP algorithms are defined by data-parallel algorithms with explicit (physical) processes in order to allow their parallel execution time to be estimated. We present here a distributed evaluation minimally synchronous for BSP execution (which corresponds to the execution model). This distributed evaluation is correct w.r.t. the call-by-value strategy of the BSlmabda_p-calculus (which corresponds to the programming model).</abstract>
    </article>
  </entry>
  <entry id="blh2000:sfp">
    <incollection>
      <author>Ballereau, O.</author>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <editor>Michaelson, G.</editor>
      <editor>Trinder, Ph.</editor>
      <booktitle>{Trends in Functional Programming}</booktitle>
      <title>{High-level BSP Programming: BSML and BS$\lambda$}</title>
      <publisher>Intellect Books</publisher>
      <year>2000</year>
      <pages>29-38</pages>
      <abstract>A functional data-parallel language called BSML is designed for programming bulk-synchronous parallel (BSP) algorithms in so-called direct mode. Its aim is to combine the generality of languages like NESL with the predictable performance of direct-mode BSP algorithms. The BSML operations are motivated and described. Experiments with a library implementation of BSML show the possibility and limitations of parallel performance prediction in this framework.</abstract>
    </incollection>
  </entry>
  <entry id="hl2000:cmpp">
    <inproceedings>
      <author>Hains, G.</author>
      <author>Loulergue, F.</author>
      <title>{Functional Bulk Synchronous Parallel Programming using the BSMLlib Library}</title>
      <booktitle>{Second} {International} {Workshop} on {Constructive} {Methods} for {Parallel} {Programming} ({CMPP'2000})</booktitle>
      <year>2000</year>
      <editor>Gorlatch, S.</editor>
      <series>Research Report MIP-2000-07</series>
      <month>June</month>
      <organisation>University of Passau</organisation>
      <year>2000</year>
      <abstract>BSMLlib is a functional data-parallel library for programming bulk-synchronous parallel (BSP) algorithms in Objective CAML. The definition of BSMLlib and performance prediction for elementary operations have been discussed in Sfp2000. This article demonstrates the expressivity of operations on elementary algorithms. Other operations, on a type of parallel sets, illustrate the advantage of explicit BSP exchange phases: the possibility of predicting and minimising communication and synchronization costs. A more complex example, inspired by parallel join algorithms for relational databases, demonstrates the advantage of using BSMLlib's explicit processes for dynamic load balancing. Finally, suggestions are made for extending the library and building a complete BSML language with the same operations.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou2000:ishpc">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{BS$\lambda_p$: Functional BSP Programs on Enumerated Vectors}</title>
      <booktitle>{International Symposium on High Performance Computing}</booktitle>
      <year>2000</year>
      <editor>Kazuki, J.</editor>
      <series>Lecture Notes in Computer Science</series>
      <number>1940</number>
      <month>October</month>
      <publisher>{Springer}</publisher>
      <pages>355-363</pages>
      <year>2000</year>
      <abstract>The BSlambda_p calculus is a calculus of functional BSP programs on enumerated parallel vectors. This confluent calculus is defined and a parallel cost model is associated with a weak call-by-value strategy. These results constitute the core of a formal design for a BSP dialect of ML.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou2000:sfp">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{Parallel Composition and Bulk Synchronous Parallel Functional Programming}</title>
      <year>2000</year>
      <booktitle>{Proceedings of the second Scottish Functional Programming Workshop}</booktitle>
      <year>2000</year>
      <editor>Gilmore, Stephen</editor>
      <address>St Andrews</address>
      <month>July</month>
      <abstract>The work described here is part of our research program to investigate new paradigms for declarative parallel programming through special interpretations of standard semantics. Our approach is a purely functional approach to programming of BSP algorithms. An attempt to add a parallel composition to this approach led to a non-confluent calculus. This paper presents a solution for adding the parallel composition to the weak call-by-value strategy of the BSlambda_p and to the BSMLlib library.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou2000:rr2000-01">
    <techreport>
      <author>Loulergue, F.</author>
      <title>Confluence of the {BS}$\lambda_p$ calculus</title>
      <institution>Université d'Orléans, LIFO</institution>
      <year>2000</year>
      <number>RR-2000-01</number>
      <month>Januray</month>
    </techreport>
  </entry>
  <entry id="blh1999:sfp">
    <inproceedings>
      <author>Ballereau, O.</author>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <title>{High-level BSP Programming: BSML and BS$\lambda$}</title>
      <booktitle>Proceedings of the first Scottish Functional Programming Workshop</booktitle>
      <pages>43-52</pages>
      <year>1999</year>
      <editor>Trinder, P</editor>
      <editor>Michaelson, G.</editor>
      <number>Techinal Report RM/99/9</number>
      <address>Edinburgh</address>
      <month>August</month>
      <organization>Heriot-Watt University</organization>
      <abstract>BSMLlib is a functional data-parallel library for programming bulk-synchronous parallel (BSP) algorithms in Objective CAML. The definition of BSMLlib and performance prediction for elementary operations have been discussed in Sfp2000. This article demonstrates the expressivity of operations on elementary algorithms. Other operations, on a type of parallel sets, illustrate the advantage of explicit BSP exchange phases: the possibility of predicting and minimising communication and synchronization costs. A more complex example, inspired by parallel join algorithms for relational databases, demonstrates the advantage of using BSMLlib's explicit processes for dynamic load balancing. Finally, suggestions are made for extending the library and building a complete BSML language with the same operations.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou2000:thesis">
    <phdthesis>
      <author>Loulergue, F.</author>
      <title>Conception de langages fonctionnels pour la programmation massivement parallèle</title>
      <school>Université d'Orléans, LIFO</school>
      <year>2000</year>
      <address>4 rue Léonard de Vinci, BP 6759, F-45067 Orléans Cedex 2, France</address>
      <type>thèse de doctorat</type>
      <month>January</month>
      <abstract>Certains problèmes nécessitent des performances que seules les machines massivement parallèles peuvent offrir. Leur programmation demeure néanmoins difficile. Les travaux étudiant le mélange de la programmation fonctionnelle et du parallélisme se répartissent en deux catégories : les extensions explicitement parallèles des langages fonctionnels - mais les langages obtenus sont soit indétermi\-nis\-tes soit brisent l'aspect fonctionnel pur - et les implantations parallèles avec sémantique fonctionnelle - mais les langages obtenus n'expriment pas directement les algorithmes parallèles et ne permettent pas la prévision des temps d'exécution. L'approche des langages à patrons, dans lesquels seulement un ensemble fixé d'opérations sont exécutées en parallèle, est intermédiaire. Leur sémantique fonctionnelle est explicite mais leur sémantique opérationnelle parallèle est implicite. L'ensemble de patrons doit être le plus complet possible mais cet ensemble s'avère dépendant du domaine d'application. Nous approfondissons cette position intermédiaire avec pour objectif de parvenir à des langages universels dans lesquels le code source permet de déterminer le coût. Cette dernière exigence nécessite que soient explicites dans les programmes les lieux du réseau de processeurs de la machine. Une approche dénotationnelle nous a amené à une étude des limites de l'expressivité des langages fonctionnels parallèles à processus explicites. Une approche opérationnelle nous a amené à définir des $\lambda$-calculs BSP (le modèle BSP ajoute une notion de processus explicites au parallélisme de données) confluents et universels pour les algorithmes BSP. Nous avons également analysé les conditions précises d'implantation parallèle de tels calculs, expérimenté le style de programmation associé et constaté qu'ils sont suffisamment expressifs et que la prévision des temps d'exécution parallèle y est possible. Abstract: Some problems require performance that only massively parallel computers offer, but their programming is still difficult. Works on functional programming and parallelism can be divided in two categories: explicit parallel extensions of functional languages - where resulting languages are either non-deterministic or non functional - and parallel implementations with functional semantics - where resulting languages don't express parallel algorithms directly and don't allow the prediction of execution times. Algorithmic skeletons languages, in which only a finite set of operations (the skeletons) are run in parallel, constitutes an intermediate approach. Their functional semantics is explicit but their parallel operational semantics is implicit. The set of algorithmic skeletons has to be as complete as possible but it is often dependent on the domain of application. We explore this intermediate position thoroughly in order to obtain universal parallel languages where source code determines execution cost. This last requirement forces the use of explicit processes corresponding to the parallel machine's processors. A denotational approach leads us to study the expressiveness of functional parallel languages with explicit processes. An operational approach leads us to define BSP lambda-calculi (the BSP model adds a notion of explicit process to data-parallelism) that are confluent and universal for BSP algoritms. We also analyze the conditions for parallel implementation of such calculi. We have experimented the associated programming style and have observed that they are sufficiently expressive and allow the prediction of execution times.</abstract>
      <note>{\small\tt http://www.univ-orleans.fr/SCIENCES/LIFO/Members/loulergu}</note>
    </phdthesis>
  </entry>
  <entry id="lhf2000:scp">
    <article>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <author>Foisy, C.</author>
      <title>{A Calculus of Functional BSP Programs}</title>
      <journal>Science of Computer Programming</journal>
      <volume>37</volume>
      <number>1-3</number>
      <year>2000</year>
      <pages>253-277</pages>
      <abstract>An extension of the lambda-calculus called BSlambda is introduced as a formal basis for functional languages expressing bulk synchronous parallel algorithms. A confluence result is shown. The application of the calculus is illustrated by examples of program proofs and the associated notion of parallel reduction. The reduction process is interpreted in the BSP cost model.</abstract>
    </article>
  </entry>
  <entry id="lou1999:jfla">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{Extension du BS$\lambda$-calcul}</title>
      <pages>93-112</pages>
      <booktitle>{JFLA}'99 : Journées Francophones des Langages Applicatifs</booktitle>
      <year>1999</year>
      <address>Morzine-Avoriaz</address>
      <editor>Weis, P.</editor>
      <month>February</month>
      <abstract>Après une présentation du calcul confluent BS$\lambda$, extension du $\lambda$-calcul par des opérations parallèles permettant l'expression d'algorithmes BSP, nous proposons trois nouvelles opérations parallèles étendant le calcul. Le calcul et cette nouvelle extension sont illustrés par différentes algorithmes de diffusion donnés dans une syntaxe à la ML.</abstract>
    </inproceedings>
  </entry>
  <entry id="hlm2001:tcs">
    <article>
      <author>Hains, G.</author>
      <author>Loulergue, F.</author>
      <author>Mullins, J.</author>
      <title>Concrete Data Structures and functional parallel programming</title>
      <journal>Theoretical Computer Science</journal>
      <year>2001</year>
      <volume>258</volume>
      <number>1-2</number>
      <pages>233-267</pages>
      <abstract>A framework is presented for designing parallel programming languages whose semantics is functional and where communications are explicit. To this end, Brookes and Geva's generalized concrete data structures are specialized with a notion of explicit data layout to yield a CCC of distributed structures called arrays. Arrays' symmetric replicated structures, suggested by the data-parallel SPMD paradigm, are found to be incompatible with sum types. We then outline a functional language with explicitly-distributed (monomorphic) concrete types, including higher-order, sum and recursive ones. In this language, programs can be as large as the network and can observe communication events in other programs. Such flexibility is missing from current data-parallel languages and amounts to a fusion with their so-called annotations, directives or meta-languages.</abstract>
    </article>
  </entry>
  <entry id="lhf1998:cmpp">
    <inproceedings>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <author>Foisy, C.</author>
      <title>{A Calculus of Recursive-Parallel BSP Programs}</title>
      <pages>59-70</pages>
      <booktitle>{First} {International} {Workshop} on {Constructive} {Methods} for {Parallel} {Programming} ({CMPP'98})</booktitle>
      <year>1998</year>
      <editor>Gorlatch, S.</editor>
      <series>Research Report MIP-9805</series>
      <month>May</month>
      <organization>University of Passau</organization>
      <abstract>An extension of the lambda-calculus called BSlambda is introduced as a formal basis for functional languages expressing bulk synchronous parallel algorithms. A local confluence result is explained and a call-by-value evaluation strategy is defined. The operational meaning of the calculus is illustrated by two programs defining the binary fold algorithm, one flat and one parallel-recursive.</abstract>
    </inproceedings>
  </entry>
  <entry id="lh1998:rr98-09">
    <techreport>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <title>{An Introduction to BS$\lambda$}</title>
      <institution>LIFO, Université d'Orléans</institution>
      <year>1998</year>
      <number>RR98-09</number>
      <month>September</month>
      <abstract>This paper is an introduction to BSlambda a calculus of parallel-recursive BSP programs. The calculus is presented, the confluence of its flat subset is stated and examples are gieven in an ML-like syntax.</abstract>
    </techreport>
  </entry>
  <entry id="lou1999:rr99-10">
    <techreport>
      <author>Loulergue, F.</author>
      <title>Confluence of the {BS}$\lambda$-calculus</title>
      <institution>LIFO, Université d'Orléans</institution>
      <year>1999</year>
      <number>RR99-10</number>
      <month>May</month>
      <abstract>The BSlambda-calculus, a formal basis for functional languages expressing bulk synchronous parallel algorithms, is presented. It is then shown to be confluent.</abstract>
    </techreport>
  </entry>
  <entry id="lou1998:renpar10">
    <inproceedings>
      <author>Loulergue, F.</author>
      <title>{BSML} : {Pro\-gram\-ma\-tion} {BSP} pu\-re\-ment fonc\-tion\-nel\-le</title>
      <booktitle>Di\-xiè\-mes {Ren\-con\-tres} {Fran\-co\-pho\-nes} du {Pa\-ral\-lé\-lis\-me} (Ren\-par'10)</booktitle>
      <year>1998</year>
      <editor>Méry, D.</editor>
      <editor>Perrin, G.-R.</editor>
      <address>Strasbourg</address>
      <month>June</month>
      <pages>243-246</pages>
      <abstract>Nous d'efinissons une extension minimale du langage fonctionnel Caml par des op'erations parall`eles BSP, d'eriv'ees d'un mod`ele d'enotationel simple avec processus explicites et statiques. Le langage obtenu, BSML, pr'eserve la s'emantique compositionnelle et permet des pr'evisions pr'ecises de performances gr^ace au mod`ele de co^uts BSP. Nous l'illustrons sur des algorithmes parall`eles de base et montrons comment un simulateur BSML permet,a`l'aide des param`etres BSP des machines, de pr'evoir les performances r'eelles.</abstract>
    </inproceedings>
  </entry>
  <entry id="lou1996:dea">
    <mastersthesis>
      <author>Loulergue, F.</author>
      <title>{P}rogrammation Parallèle Fonctionnelle en Processus Statiques: une Approche {D}énotationnelle</title>
      <school>{LIFO}, {U}niversité d'{O}rléans</school>
      <year>1996</year>
      <type>{Mémoire} de {DEA} d'Informatique</type>
      <month>Septembre</month>
    </mastersthesis>
  </entry>
  <entry id="lh1997:europar">
    <inproceedings>
      <author>Loulergue, F.</author>
      <author>Hains, G.</author>
      <title>Parallel Functional Programming with Explicit Processes: Beyond SPMD</title>
      <booktitle>{Euro-Par'97} Parallel Processing</booktitle>
      <year>1997</year>
      <editor>Lengauer, C.</editor>
      <editor>Griebl, M.</editor>
      <editor>Gorlatch, S.</editor>
      <number>1300</number>
      <series>Lecture Notes in Computer Science</series>
      <address>Passau, Germany</address>
      <month>August</month>
      <publisher>{Springer}</publisher>
      <pages>530-537</pages>
      <abstract>This paper presents the design for a purely functional parallel language with higher-order functions. Data layout is explicit in the language and arbitrary synchronizations can be specified in the non-standard type system based on concrete data structures. We present its denotational semantics, operational semantics, full abstraction property and program examples to illustrate its key features.</abstract>
    </inproceedings>
  </entry>
  <entry id="lh1997:jfla">
    <inproceedings>
      <author>Loulergue, F.</author>
      <author>Hains, G</author>
      <title>{P}rogrammation Fonctionnelle Parallèle en Processus Statiques: Une Approche {D}énotationnelle</title>
      <booktitle>{Journées} Francophones des Langages Applicatifs {JFLA'97}</booktitle>
      <year>1997</year>
      <editor>Gengler, M.</editor>
      <editor>Queinnec, C.</editor>
      <publisher>{INRIA}</publisher>
      <abstract>This paper presents the design for a purely functional parallel language with higher-order functions. It is based on specialisation of a non-standard model of lambda calculus (concrete data structure): array data structures. We present its denotational semantics, operational semantics, full abstraction property and program examples to illustrate its key features.</abstract>
    </inproceedings>
  </entry>
  <entry id="tr-2002-10">
    <techreport>
      <title>{Efficiency of Bulk Synchronous Parallel Programming using C++, BSCF++ and BSMLlib}</title>
      <author>Dabrowski, F.</author>
      <author>Loulergue, F.</author>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2002</year>
      <number>2002-10</number>
      <month>June</month>
      <abstract>The BSMLlib library is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. The BSFC++ library is a library for Functional Bulk Synchronous Parallel programming in C++ which is based on the FC++ library. We present those libraries and give experimental results. For comparaison, MPI/C++ versions of the same programs were also ran on our cluster of PCs.</abstract>
    </techreport>
  </entry>
  <entry id="tr-2002-11">
    <techreport>
      <title>{Implementation of the BSMLlib Library v0.2}</title>
      <author>Loulergue, Frédéric</author>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2002</year>
      <month>July</month>
      <number>2002-11</number>
      <abstract>The BSMLlib is a library for Bulk Synchronous Parallel (BSP) programming with the functional language Objective Caml. It is based on an extension of the $\lambda$-calcul by parallel operations on a parallel data structure named parallel vector, which is given by intention. A first implementation of this library was based on the BSPlib library, which is not longer supported nor updated. Being the basis of a framework for Grid computing, a new implementation of the BSMLlib based on MPI has been designed. Experimental results on a cluster of PCs are presented.</abstract>
    </techreport>
  </entry>
  <entry id="tr-2002-13">
    <techreport>
      <title>{Functional Bulk Synchronous Parallel Programming in C++}</title>
      <author>Dabrowski, F.</author>
      <author>Loulergue, F.</author>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2002</year>
      <month>August</month>
      <number>2002-13</number>
      <abstract>This paper presents the BSFC++ library for functional bulk synchronous parallel programming in C++. It is based on an extension of the $\lambda$-calculus by parallel operations on a parallel data structure named parallel vector, which is given by intention. This guarantees the determinism and the absence of deadlock. Broadcast algorithms are implemented using the core library.</abstract>
    </techreport>
  </entry>
  <entry id="tr-2001-02">
    <techreport>
      <author>Loulergue, F.</author>
      <title>{The BS$\lambda_p$-calculus and the Distributed Evaluation}</title>
      <institution>University of Paris Val-de-Marne, LACL</institution>
      <year>2001</year>
      <number>2001-02</number>
      <abstract>The BS$\lambda_p$-calculus is a calculus of functional bulk synchronous parallel (BSP) programs. It is the basis for the design of a bulk synchronous parallel ML language. For data-parallel languages, there are two points of view: the programming model where a program is seen as a sequence of operations on parallel vectors, and the execution model where the program is a parallel composition of programs run on each processor of the parallel machine. BSP algorithms are defined by data-parallel algorithms with explicit (physical) processes in order to allow their parallel execution time to be estimated. We present here a distributed evaluation minimally synchronous for BSP execution (which corresponds to the execution model). This distributed evaluation is correct w.r.t.\ the call-by-value strategy of the BS$\lambda_p$-calculus (which corresponds to the programming model).</abstract>
    </techreport>
  </entry>
  <entry id="sykm:sas03">
    <inproceedings>
      <author>Shaham, R.</author>
      <author>Yahav, E.</author>
      <author>Kolodner, E. K.</author>
      <author>Sagiv, Mooly</author>
      <title>Establishing Local Temporal Heap Safety Properties with Applications to Compile-Time Memory Management</title>
      <booktitle>Proc. of Static Analysis Symposium (SAS'03)</booktitle>
      <year>2003</year>
      <volume>2694</volume>
      <series>LNCS</series>
      <pages>483-503</pages>
      <month>June</month>
      <publisher>Springer</publisher>
    </inproceedings>
  </entry>
  <entry id="fgry:sas03">
    <inproceedings>
      <author>Field, J.</author>
      <author>Goyal, D.</author>
      <author>Ramalingam, G.</author>
      <author>Yahav, E.</author>
      <title>Typestate Verification: Abstraction Techniques and Complexity Results</title>
      <booktitle>Proc. of Static Analysis Symposium (SAS'03)</booktitle>
      <year>2003</year>
      <volume>2694</volume>
      <series>LNCS</series>
      <pages>439-462</pages>
      <month>June</month>
      <publisher>Springer</publisher>
    </inproceedings>
  </entry>
  <entry id="yrsw03:esop03">
    <inproceedings>
      <author>Yahav, E.</author>
      <author>Reps, T.</author>
      <author>Sagiv, M.</author>
      <author>Wilhelm, R.</author>
      <title>Verifying Temporal Heap Properties Specified via Evolution Logic</title>
      <booktitle>Proc. of the 12th European Symposium on Programming, ESOP 2003</booktitle>
      <series>LNCS</series>
      <volume>2618</volume>
      <year>2003</year>
      <month>April</month>
    </inproceedings>
  </entry>
  <entry id="pires2002">
    <techreport>
      <author>Pires, Paulo S. Motta</author>
      <title>Introducao ao Scilab</title>
      <year>2001</year>
      <note>Technical Report in Portuguese about Scilab</note>
      <url>http://www.dca.ufrn.br/pmotta</url>
    </techreport>
  </entry>
  <entry id="stpiczynski:2003:alp">
    <article>
      <author>Stpiczy{\'n}ski, Przemys{\l}aw</author>
      <year>2003</year>
      <title>Ada as a language for programming clusters of SMPs</title>
      <journal>Ann. Univ. Mariae Curie-Sklodowska Informatica</journal>
      <volume>1</volume>
      <pages>73-79</pages>
      <abstract>This paper presents a new idea of developing parallel programs for clusters of SMP nodes using the Ada programming language. We show how to implement OpenMP in Ada and simplify programming of distributed memory applications using remote subprograms calls instead of complicated message passing.</abstract>
      <url>http://www.ika.edu.pl:8000/ai/2003/08.pdf</url>
    </article>
  </entry>
  <entry id="pop-xml">
    <inproceedings>
      <author>Pop, Adrian</author>
      <author>Fritzson, Peter</author>
      <year>2003</year>
      <title>{ModelicaXML: A Modelica XML Representation with Applications}</title>
      <booktitle>Proceedings of the 3th International Modelica Conference</booktitle>
      <month>3-4 October</month>
      <location>Linkoping, Sweden</location>
      <pdf-url>http://www.modelica.org/Conference2003/papers/h39_Pop.pdf</pdf-url>
    </inproceedings>
  </entry>
  <entry id="modelica-site">
    <misc>
      <author>Association, The Modelica</author>
      <title>Modelica</title>
      <howpublished>\href{http://www.modelica.org}{\texttt{http://www.modelica.org}}</howpublished>
    </misc>
  </entry>
  <entry id="momigliano2003olf">
    <inproceedings>
      <author>Momigliano, Alberto</author>
      <author>Polakow, Jeff</author>
      <title>A formalization of an Ordered Logical Framework in Hybrid with applications to continuation machines</title>
      <booktitle>Proceedings of the 2003 workshop on Mechanized reasoning about languages with variable binding</booktitle>
      <year>2003</year>
      <isbn>1-58113-800-8</isbn>
      <pages>1-9</pages>
      <location>Uppsala, Sweden</location>
      <doi>http://doi.acm.org/10.1145/976571.976581</doi>
      <publisher>ACM Press</publisher>
    </inproceedings>
  </entry>
  <entry id="ambler2003">
    <inproceedings>
      <author>Ambler, S. J.</author>
      <author>Crole, R. L.</author>
      <author>Momigliano, Alberto</author>
      <title>A definitional approach to primitivexs recursion over higher order abstract syntax</title>
      <booktitle>Proceedings of the 2003 workshop on Mechanized reasoning about languages with variable binding</booktitle>
      <year>2003</year>
      <isbn>1-58113-800-8</isbn>
      <pages>1-11</pages>
      <location>Uppsala, Sweden</location>
      <doi>http://doi.acm.org/10.1145/976571.976572</doi>
      <publisher>ACM Press</publisher>
    </inproceedings>
  </entry>
  <entry id="johann-voigtlaender:popl:2004">
    <inproceedings>
      <author>Johann, Patricia</author>
      <author>Voigtländer, Janis</author>
      <title>Free Theorems in the Presence of seq</title>
      <editor>Jones, Neil D.\</editor>
      <editor>Leroy, Xavier</editor>
      <booktitle>31st Symposium on Principles of Programming Languages, Venice, Italy, Proceedings</booktitle>
      <series>ACM SIGPLAN Notices</series>
      <volume>39</volume>
      <number>1</number>
      <year>2004</year>
      <month>January 14-16</month>
      <publisher>ACM Press</publisher>
      <pages>99-110</pages>
      <abstract>Parametric polymorphism constrains the behavior of pure functional programs in a way that allows the derivation of interesting theorems about them solely from their types, i.e., virtually for free. Unfortunately, the standard parametricity theorem fails for nonstrict languages supporting a polymorphic strict evaluation primitive like Haskell's $\mathit{seq}$. Contrary to the folklore surrounding $\mathit{seq}$ and parametricity, we show that not even quantifying only over strict and bottom-reflecting relations in the $\forall$-clause of the underlying logical relation -- and thus restricting the choice of functions with which such relations are instantiated to obtain free theorems to strict and total ones -- is sufficient to recover from this failure. By addressing the subtle issues that arise when propagating up the type hierarchy restrictions imposed on a logical relation in order to accommodate the strictness primitive, we provide a parametricity theorem for the subset of Haskell corresponding to a Girard-Reynolds-style calculus with fixpoints, algebraic datatypes, and $\mathit{seq}$. A crucial ingredient of our approach is the use of an asymmetric logical relation, which leads to ``inequational'' versions of free theorems enriched by preconditions guaranteeing their validity in the described setting. Besides the potential to obtain corresponding preconditions for standard equational free theorems by combining some new inequational ones, the latter also have value in their own right, as is exemplified with a careful analysis of $\mathit{seq}$'s impact on familiar program transformations.</abstract>
      <keywords>controlling strict evaluation</keywords>
      <keywords>correctness proofs</keywords>
      <keywords>denotational semantics</keywords>
      <keywords>Haskell</keywords>
      <keywords>logical relations</keywords>
      <keywords>parametricity</keywords>
      <keywords>program transformations</keywords>
      <keywords>short cut fusion</keywords>
      <keywords>theorems for free</keywords>
      <url>http://doi.acm.org/10.1145/964001.964010</url>
    </inproceedings>
  </entry>
  <entry id="giesl-kuehnemann-voigtlaender:asian:2003">
    <inproceedings>
      <author>Giesl, Jürgen</author>
      <author>Kühnemann, Armin</author>
      <author>Voigtländer, Janis</author>
      <title>Deaccumulation -- Improving Provability</title>
      <editor>Saraswat, Vijay A.\</editor>
      <booktitle>Eighth Asian Computing Science Conference, Mumbai, India, Proceedings</booktitle>
      <series>Lecture Notes in Computer Science</series>
      <volume>2896</volume>
      <year>2003</year>
      <month>December 10-12</month>
      <publisher>Springer-Verlag</publisher>
      <pages>146-160</pages>
      <abstract>Several induction theorem provers were developed to verify functional programs mechanically. Unfortunately, automated verification usually fails for functions with accumulating arguments. In particular, this holds for tail-recursive functions that correspond to imperative programs, but also for programs with nested recursion. Based on results from the theory of tree transducers, we develop an automatic transformation technique. It transforms accumulative functional programs into non-accumulative ones, which are much better suited for automated verification by induction theorem provers. Hence, in contrast to classical program transformations aiming at improving the efficiency, the goal of our deaccumulation technique is to improve the provability.</abstract>
      <url>http://www.springerlink.com/openurl.asp?genre=article&amp;issn=0302-9743&amp;volume=2896&amp;spage=146</url>
    </inproceedings>
  </entry>
  <entry id="voigtlaender-kuehnemann:jfp:2004">
    <article>
      <author>Voigtländer, Janis</author>
      <author>Kühnemann, Armin</author>
      <title>Composition of functions with accumulating parameters</title>
      <journal>Journal of Functional Programming</journal>
      <volume>14</volume>
      <issue>3</issue>
      <pages>317-363</pages>
      <publisher>Cambridge University Press</publisher>
      <year>2004</year>
      <month>May</month>
      <abstract>Many functional programs with accumulating parameters are contained in the class of macro tree transducers. We present a program transformation technique that can be used to solve the efficiency problems due to creation and consumption of intermediate data structures in compositions of such functions, where classical deforestation techniques fail. To do so, given two macro tree transducers under appropriate restrictions, we construct a single macro tree transducer that implements the composition of the two original ones. The imposed restrictions are more liberal than those in the literature on macro tree transducer composition, thus generalising previous results.</abstract>
      <url>http://dx.doi.org/10.1017/S0956796803004933</url>
    </article>
  </entry>
  <entry id="voigtlaender:hosc:2004">
    <article>
      <author>Voigtländer, Janis</author>
      <title>Using Circular Programs to Deforest in Accumulating Parameters</title>
      <journal>Higher-Order and Symbolic Computation</journal>
      <volume>17</volume>
      <issue>1-2</issue>
      <pages>129-163</pages>
      <publisher>Kluwer Academic Publishers</publisher>
      <year>2004</year>
      <abstract>This paper presents a functional program transformation that removes intermediate data structures in compositions of two members of a class of recursive functions with accumulating parameters. To avoid multiple traversals of the input data structure, the composition algorithm produces circular programs that make essential use of lazy evaluation and local recursion. The resulting programs are simplified using a post-processing phase sketched in the paper. The presented transformation, called lazy composition, is compared with related transformation techniques both on a qualitative level and based on runtime measurements. An alternative use of higher-orderedness instead of circularity is also briefly explored.</abstract>
      <keywords>program transformation</keywords>
      <keywords>intermediate results</keywords>
      <keywords>accumulating arguments</keywords>
      <keywords>circular programs</keywords>
      <keywords>tupling</keywords>
      <keywords>unfold/fold</keywords>
      <keywords>(short cut) deforestation</keywords>
      <keywords>tree transducers</keywords>
      <url>http://dx.doi.org/10.1023/B:LISP.0000029450.36668.cb</url>
    </article>
  </entry>
  <entry id="grabmuellerhofstedt2003turtle">
    <inproceedings>
      <author>Grabmüller, Martin</author>
      <author>Hofstedt, Petra</author>
      <title>{Turtle: A Constraint Imperative Programming Language}</title>
      <editor>Coenen, Frans</editor>
      <editor>Preece, Alun</editor>
      <editor>Macintosh, Ann</editor>
      <booktitle>Twenty-third SGAI International Conference on Innovative Techniques and Applications of Artificial Intelligence</booktitle>
      <year>2003</year>
      <number>XX</number>
      <series>Research and Development in Intelligent Systems</series>
      <address>Cambridge, UK</address>
      <month>December</month>
      <organization>British Computer Society</organization>
      <publisher>Springer-Verlag</publisher>
      <isbn>1-85233-780-X</isbn>
      <abstract>Ideally, in constraint programs, the solutions of problems are obtained by specifying their desired properties, whereas in imperative programs, the steps which lead to a solution must be defined explicitly, rather than being derived automatically. This paper describes the design and implementation of the programming language Turtle, which integrates declarative constraints and imperative language elements in order to combine their advantages and to form a more flexible programming paradigm suitable for solving a wide range of problems.</abstract>
    </inproceedings>
  </entry>
  <entry id="pkh03a">
    <inproceedings>
      <author>Pearce, D. J.</author>
      <author>Kelly, P. H. J.</author>
      <author>Hankin, C.</author>
      <title>Online Cycle Detection and Difference Propagation for Pointer Analysis</title>
      <booktitle>Proceedings of the IEEE workshop on Source Code Analysis and Manipulation</booktitle>
      <institution>Imperial College</institution>
      <pages>3-12</pages>
      <year>2003</year>
    </inproceedings>
  </entry>
  <entry id="pkh04a">
    <inproceedings>
      <author>Pearce, D. J.</author>
      <author>Kelly, P. H. J.</author>
      <author>Hankin, C.</author>
      <title>Efficient Field-sensitive pointer analysis for C</title>
      <booktitle>Proceedings of the ACM workshop on Program Analysis for Software Tools and Engineering PASTE</booktitle>
      <institution>Imperial College</institution>
      <year>2004</year>
      <publisher>{ACM} Press</publisher>
    </inproceedings>
  </entry>
  <entry id="fotp04">
    <inproceedings>
      <author>Fursin, G.</author>
      <author>O'Boyle, M.</author>
      <author>Temam, O.</author>
      <author>Watts, G.</author>
      <title>Fast and Accurate Method for Determining a Lower Bound on Execution Time</title>
      <booktitle>Concurrency Practice and Experience</booktitle>
      <volume>16</volume>
      <number>2-3</number>
      <pages>271-292</pages>
      <year>2004</year>
    </inproceedings>
  </entry>
  <entry id="fur04">
    <phdthesis>
      <author>Fursin, G.</author>
      <title>Iterative Compilation and Performance Prediction for Numerical Applications</title>
      <year>2004</year>
      <address>United Kingdom</address>
      <school>University of Edinburgh</school>
    </phdthesis>
  </entry>
  <entry id="fok02">
    <inproceedings>
      <author>Fursin, G. G.</author>
      <author>O'Boyle, M. F. P.</author>
      <author>Knijnenburg, P. M. W.</author>
      <title>Evaluating Iterative Compilation</title>
      <booktitle>Proc. Languages and Compilers for Parallel Computers (LCPC)</booktitle>
      <pages>305-315</pages>
      <year>2002</year>
    </inproceedings>
  </entry>
  <entry id="fotp01">
    <inproceedings>
      <author>Fursin, G.</author>
      <author>O'Boyle, M.</author>
      <author>Temam, O.</author>
      <author>Watts, G.</author>
      <title>Fast and Accurate Evaluation of Memory Performance Upper-Bound</title>
      <booktitle>Proceedings of the 9th Workshop on Compilers for Parallel Computers (CPC'2001)</booktitle>
      <pages>163-172</pages>
      <year>2001</year>
    </inproceedings>
  </entry>
  <entry id="abella00mhaoteu">
    <misc>
      <author>Abella, J.</author>
      <author>Touati, S. A. A.</author>
      <author>Anderson, A.</author>
      <author>Ciuraneta, C.</author>
      <author>Dai, J. M. Codina M.</author>
      <author>Eisenbeis, C.</author>
      <author>Fursin, G.</author>
      <author>Gonzalez, A.</author>
      <author>Llosa, J.</author>
      <author>O'Boyle, M.</author>
      <author>Randrianatoavina, A.</author>
      <author>Sanchez, J.</author>
      <author>Temam, O.</author>
      <author>Vera, X.</author>
      <author>Watts, G.</author>
      <title>The MHAOTEU Toolset for Memory Hierarchy Management</title>
      <booktitle>16th IMACS World Congress on Scientific Computation, Applied Mathematics and Simulation</booktitle>
      <year>2000</year>
    </misc>
  </entry>
  <entry id="dblp:conf/icfp/2003merlin">
    <proceedings>
      <title>Eighth ACM SIGPLAN International Conference on Functional Programming, Workshop on Mechanized reasoning about languages with variable binding, MERLIN 2003, Uppsala, Sweden, August 2003</title>
      <editor>Honsell, Furio</editor>
      <editor>Miculan, Marino</editor>
      <editor>Momigliano, Alberto</editor>
      <booktitle>MERLIN 2003</booktitle>
      <publisher>ACM</publisher>
      <year>2003</year>
      <bibsource>DBLP, http://dblp.uni-trier.de</bibsource>
    </proceedings>
  </entry>
  <entry id="certification:lpar2004">
    <inproceedings>
      <author>Alberto Momigliano Lennart Beringer, Martin Hofmann</author>
      <author>Shkaravska, Olha</author>
      <title>Automatic Certification of Heap Consumption</title>
      <booktitle>Logic for Programming, Artificial Intelligence, and Reasoning: 11th International Conference, LPAR 2004, Montevideo, Uruguay, March 14-18, 2005. Proceedings</booktitle>
      <pages>347-362</pages>
      <year>2005</year>
      <editor>Baader, Andrei Voronkov Franz</editor>
      <volume>3425</volume>
      <series>Lecture Notes in Computer Science</series>
      <month>February</month>
      <publisher>Publisher: Springer-Verlag GmbH</publisher>
      <optnote>ISBN: 3-540-25236-3</optnote>
      <pdf>lpar.pdf</pdf>
    </inproceedings>
  </entry>
  <entry id="pinapa">
    <inproceedings>
      <author>Moy, Matthieu</author>
      <author>Maraninchi, Florence</author>
      <author>Maillet-Contoz, Laurent</author>
      <title>{Pinapa}: An Extraction Tool for System{C} descriptions of Systems-on-a-Chip</title>
      <booktitle>EMSOFT</booktitle>
      <year>2005</year>
      <month>September</month>
      <url>http://www-verimag.imag.fr/moy/publications/sc-compil.pdf</url>
      <code>http://greensocs.sourceforge.net/pinapa/</code>
      <abstract>SystemC is becoming a de-facto standard for the description of complex systems-on-a-chip. It enables system-level descriptions of SoCs: the same language is used for the description of the architecture, software and hardware parts. A tool like pinapa is compulsory to work on realistic SoCs designs for anything else than simulation: it is able to extract both architecture and behavior information from SystemC code, with very few limitations. pinapa can be used as a front-end for various analysis tools, ranging from ``superlint'' to model-checking. It is open source and available from http://greensocs.sourceforge.net/pinapa/. There exists no equivalent tool for SystemC up to now.</abstract>
    </inproceedings>
  </entry>
  <entry id="voi05a">
    <phdthesis>
      <author>Voigtländer, Janis</author>
      <title>Tree Transducer Composition as Program Transformation</title>
      <year>2005</year>
      <school>Technische Universität Dresden</school>
      <publisher>Der Andere Verlag</publisher>
      <abstract>Nonstrict, purely functional programming languages offer a high potential for the modularization of software. But beside their advantages with respect to reliability and reusability, modularly specified programs often have the disadvantage of low execution efficiency, caused in particular by the creation and consumption of structured intermediate results. One possible approach to cure this conflict is the automatic, semantics-preserving optimization of programs, for which purely functional languages are again particularly suited due to their mathematical foundation. This dissertation studies a specific transformation for the elimination of intermediate results (for so called deforestation) regarding its impact on the program efficiency under nonstrict evaluation. The formal framework is provided by concepts from the theory of tree transducers. One special feature of the transformation under consideration is the successful handling of accumulating parameters, which find frequent use in functional programs. The core of the thesis is the derivation of effectively decidable, syntactic conditions on the original program under which the transformed program is to be preferred over it with respect to efficiency.</abstract>
    </phdthesis>
  </entry>
  <entry id="merlin05">
    <proceedings>
      <editor>Momigliano, Alberto</editor>
      <editor>Pollack, Randy</editor>
      <title>{MERLIN} '05: Proceedings of the 3rd {ACM} {SIGPLAN} workshop on Mechanized reasoning about languages with variable binding</title>
      <year>2005</year>
      <isbn>1-59593-072-8</isbn>
      <location>Tallinn, Estonia</location>
      <order_no>565058</order_no>
      <publisher>ACM Press</publisher>
      <address>New York, NY, USA</address>
    </proceedings>
  </entry>
  <entry id="jv06">
    <article>
      <author>Johann, Patricia</author>
      <author>Voigtländer, Janis</author>
      <title>The Impact of seq on Free Theorems-Based Program Transformations</title>
      <journal>Fundamenta Informaticae</journal>
      <volume>69</volume>
      <issue>1-2</issue>
      <pages>63-102</pages>
      <year>2006</year>
      <publisher>IOS Press</publisher>
      <abstract>Parametric polymorphism constrains the behavior of pure functional programs in a way that allows the derivation of interesting theorems about them solely from their types, i.e., virtually for free. Unfortunately, standard parametricity results -- including so-called free theorems -- fail for nonstrict languages supporting a polymorphic strict evaluation primitive such as Haskell's $\mathit{seq}$. A folk theorem maintains that such results hold for a subset of Haskell corresponding to a Girard-Reynolds calculus with fixpoints and algebraic datatypes \textit{even when $\mathit{seq}$ is present} provided the relations which appear in their derivations are required to be bottom-reflecting and admissible. In this paper we show that this folklore is incorrect, but that parametricity results \textit{can} be recovered in the presence of $\mathit{seq}$ by restricting attention to left-closed, total, and admissible relations instead. The key novelty of our approach is the asymmetry introduced by left-closedness, which leads to ``inequational'' versions of standard parametricity results together with preconditions guaranteeing their validity even when $\mathit{seq}$ is present. We use these results to derive criteria ensuring that both equational and inequational versions of short cut fusion and related program transformations based on free theorems hold in the presence of $\mathit{seq}$.</abstract>
      <keywords>Haskell</keywords>
      <keywords>control primitives</keywords>
      <keywords>correctness proofs</keywords>
      <keywords>denotational semantics</keywords>
      <keywords>functional programming languages</keywords>
      <keywords>logical relations</keywords>
      <keywords>mixing strict and nonstrict evaluation</keywords>
      <keywords>parametricity</keywords>
      <keywords>polymorphism</keywords>
      <keywords>program transformations</keywords>
      <keywords>rank-2 types</keywords>
      <keywords>short cut fusion</keywords>
      <keywords>theorems for free</keywords>
    </article>
  </entry>
  <entry id="dblp:conf/asplos/suhlzd04">
    <inproceedings>
      <author>Suh, G. Edward</author>
      <author>Lee, Jae W.</author>
      <author>Zhang, David</author>
      <author>Devadas, Srinivas</author>
      <title>Secure program execution via dynamic information flow tracking.</title>
      <booktitle>ASPLOS</booktitle>
      <year>2004</year>
      <pages>85-96</pages>
      <ee>http://doi.acm.org/10.1145/1024393.1024404</ee>
      <crossref>DBLP:conf/asplos/2004</crossref>
      <bibsource>DBLP, http://dblp.uni-trier.de</bibsource>
    </inproceedings>
  </entry>
  <entry id="foster99theory">
    <inproceedings>
      <author>Foster, Jeffrey S.</author>
      <author>Fahndrich, Manuel</author>
      <author>Aiken, Alexander</author>
      <title>A Theory of Type Qualifiers</title>
      <booktitle>{SIGPLAN} Conference on Programming Language Design and Implementation</booktitle>
      <pages>192-203</pages>
      <year>1999</year>
      <url>citeseer.ist.psu.edu/foster99theory.html</url>
    </inproceedings>
  </entry>
  <entry id="conf/sigcse/nguyenrw05">
    <inproceedings>
      <title>Design patterns for parsing</title>
      <author>Nguyen, Dung Zung</author>
      <author>Ricken, Mathias</author>
      <author>Wong, Stephen</author>
      <affiliation>Dept. of Computer Science, Rice University</affiliation>
      <bibdate>2006-02-15</bibdate>
      <bibsource>DBLP, http://dblp.uni-trier.de/db/conf/sigcse/sigcse2005.html#NguyenRW05</bibsource>
      <booktitle>SIGCSE</booktitle>
      <booktitle>Proceedings of the 36th SIGCSE Technical Symposium on Computer Science Education, SIGCSE 2005, St. Louis, Missouri, USA, February 23-27, 2005</booktitle>
      <publisher>ACM</publisher>
      <year>2005</year>
      <editor>Dann, Wanda</editor>
      <editor>Naps, Thomas L.</editor>
      <editor>Tymann, Paul T.</editor>
      <editor>Baldwin, Doug</editor>
      <isbn>1-58113-997-7</isbn>
      <pages>477-481</pages>
      <url>http://doi.acm.org/10.1145/1047344.1047497;http://www.exciton.cs.rice.edu/research/sigcse05/dp4rdp.pdf;http://www.exciton.cs.rice.edu/research/sigcse05/dp4rdp.ppt</url>
    </inproceedings>
  </entry>
  <entry id="gettys90">
    <article>
      <author>Saha, Goutam Kumar</author>
      <title>Software Based Transient-Fault Tolerance</title>
      <journal>International Journal of Mathematics and Computer Science</journal>
      <volume>1</volume>
      <number>2</number>
      <year>2006</year>
      <abstract>A very fast noble software- based error detection and correction technique has been demonstrated in this innovative paper by Goutam Kumar Saha, a distinguished Computer Scientist.</abstract>
    </article>
  </entry>
  <entry id="conf/euroforth/global">
    <inproceedings>
      <title>Global Stack Allocation</title>
      <author>Shannon, Mark</author>
      <author>Bailey, Chris</author>
      <booktitle>Procedings of EuroForth 2006</booktitle>
      <year>2006</year>
      <url>http://dec.bournemouth.ac.uk/forth/euro/ef06/shannon-bailey06.pdf</url>
    </inproceedings>
  </entry>
  <entry id="shannon06">
    <inproceedings>
      <title>Global Stack Allocation</title>
      <author>Shannon, Mark</author>
      <author>Bailey, Chris</author>
      <booktitle>Procedings of EuroForth 2006</booktitle>
      <year>2006</year>
      <url>http://dec.bournemouth.ac.uk/forth/euro/ef06/shannon-bailey06.pdf</url>
    </inproceedings>
  </entry>
  <entry id="giavitto06b">
    <inbook>
      <author>Giavitto, Jean-Louis</author>
      <author>Spicher, Antoine</author>
      <editor>Lesne, Annick</editor>
      <editor>Bourgine, Paul</editor>
      <title>Morphogense</title>
      <publisher>Belin</publisher>
      <year>2006</year>
      <pages>178-198</pages>
      <abstract>Ce chapitre prend place dans un ouvrage pluridisciplinaire consacr l'observation et la cration des formes, de la physique l'informatique en passant par la gographie et la biologie. Il prsente plusieurs formalismes apparent la rcriture qui ont t utiliss dans la modlisation de processus de croissance, en particulier en biologie. Il introduit l'ide que le dveloppement peut tre vue comme un systme dynamique o la structure elle-mme du systme varie au cours du temps.</abstract>
    </inbook>
  </entry>
  <entry id="giavitto06c">
    <inbook>
      <author>Giavitto, Jean-Louis</author>
      <author>Spicher, Antoine</author>
      <editor>Krasnogor, Natalio</editor>
      <editor>Gustafson, Steve</editor>
      <editor>Pelta, David</editor>
      <editor>Verdegay, Jose L.</editor>
      <title>Systems Self-Assembly: multidisciplinary snapshots</title>
      <publisher>Elsevier</publisher>
      <year>2006</year>
      <abstract>We present in this chapter the use of MGS, a declarative and rule-based language dedicated to the modeling and the simulation of various morphogenetic and developmental processes, like self-assembly processes. The MGS approach relies on the introduction of a topological point of view on various data structures called topological collections. This topological approach enables a uniform handling of theses data structure by a new kind of rewriting rules called transformations. Using (local) rewriting rules to specify self-assembling processes is particularly adequate because it mimics closely the incremental building mechanism of the real phenomena. The MGS approach is illustrated on the fabrication of a fractal pattern, a Sierpinsky triangle, using two approaches: by accretive growth and by carving. More generally, the notions of topological collections and transformations available in MGS enable the easy and concise modeling of cellular automata on various lattice geometries as well as more arbitrary constructions of multi-dimensional objects.</abstract>
    </inbook>
  </entry>
  <entry id="paller05increasing">
    <misc>
      <author>PALLER, G.</author>
      <title>Increasing Java Performance in MemoryConstrained Environments Using Explicit Memory Deallocation</title>
      <text>G. PALLER, Increasing Java Performance in MemoryConstrained Environments Using Explicit Memory Deallocation, International Workshop on Mobility Aware Computing, Erfurt, Germany, Sept. 2005</text>
      <year>2005</year>
      <url>citeseer.ist.psu.edu/paller05increasing.html</url>
    </misc>
  </entry>
  <entry id="savinov:2007:cum">
    <techreport>
      <author>Savinov, Alexandr</author>
      <title>Concepts and their Use for Modelling Objects and References in Programming Languages</title>
      <institution>Institute of Mathematics and Computer Science, Academy of Sciences of Moldova</institution>
      <type>Technical Report</type>
      <pages>43</pages>
      <year>2007</year>
      <language>en</language>
      <keywords>concept-oriented programming</keywords>
      <keywords>concept inclusion</keywords>
      <keywords>representation and access</keywords>
      <keywords>indirection</keywords>
      <keywords>aspect-oriented programming</keywords>
      <keywords>object-oriented programming</keywords>
      <keywords>mixins</keywords>
      <abstract>In the paper a new programming construct, called concept, is introduced. Concept is pair of two classes: a reference class and an object class. Instances of the reference classes are passed-by-value and are intended to represent objects. Instances of the object class are passed-by-reference. An approach to programming where concepts are used instead of classes is called concept-oriented programming (CoP). In CoP objects are represented and accessed indirectly by means of references. The structure of concepts describes a hierarchical space with a virtual address system. The paper describes this new approach to programming including such mechanisms as reference resolution, complex references, method interception, dual methods, life-cycle management inheritance and polymorphism.</abstract>
      <rights>unrestricted</rights>
      <url>http://conceptoriented.com/savinov/publicat/imi-report_07.pdf</url>
    </techreport>
  </entry>
  <entry id="savinov:2006:ior">
    <techreport>
      <author>Savinov, Alexandr</author>
      <title>Indirect Object Representation and Access by Means of Concepts</title>
      <institution>Institute of Mathematics and Computer Science, Academy of Sciences of Moldova</institution>
      <type>Technical Report</type>
      <pages>8</pages>
      <year>2006</year>
      <language>en</language>
      <keywords>concept-oriented programming</keywords>
      <keywords>concept inclusion</keywords>
      <keywords>representation and access</keywords>
      <keywords>indirection</keywords>
      <keywords>aspect-oriented programming</keywords>
      <keywords>object-oriented programming</keywords>
      <keywords>mixins</keywords>
      <abstract>The paper describes a mechanism for indirect object representation and access (ORA) in programming languages. The mechanism is based on using a new programming construct which is referred to as concept. Concept consists of one object class and one reference class both having their fields and methods. The object class is the conventional class as defined in OOP with instances passed by reference. Instances of the reference class are passed by value and are intended to represent objects. The reference classes are used to describe how objects have to be represented and accessed by providing custom format for their identifiers and custom access procedures. Such an approach to programming where concepts are used instead of classes is referred to as concept-oriented programming. It generalizes OOP and its main advantage is that it allows the programmer to describe not only the functionality of target objects but also intermediate functions which are executed behind the scenes as an object is being accessed.</abstract>
      <rights>unrestricted</rights>
      <url>http://conceptoriented.com/savinov/publicat/imi-report_06.pdf</url>
    </techreport>
  </entry>
  <entry id="savinov:2005:cgc">
    <article>
      <author>Savinov, Alexandr</author>
      <title>Concept as a Generalization of Class and Principles of the Concept-Oriented Programming</title>
      <journal>Computer Science Journal of Moldova</journal>
      <volume>13</volume>
      <number>3</number>
      <pages>292-335</pages>
      <year>2005</year>
      <language>en</language>
      <keywords>concept-oriented programming</keywords>
      <keywords>concept inclusion</keywords>
      <keywords>representation and access</keywords>
      <keywords>indirection</keywords>
      <keywords>aspect-oriented programming</keywords>
      <keywords>object-oriented programming</keywords>
      <keywords>mixins</keywords>
      <abstract>In the paper we describe a new construct which is referred to as concept and a new concept-oriented approach to programming. Concept generalizes conventional classes and consists of two parts: an objects class and a reference class. Each concept has a parent concept specified via inclusion relation. Instances of reference class are passed by value and are intended to represent instances of child object classes. The main role of concepts consists in indirecting object representation and access. In concept-oriented programming it is assumed that a system consists of (i) conventional target business methods (BMs), and (ii) hidden representation and access (RA) methods. If conventional classes are used to describe only BMs then concepts allow the programmer to describe both types of functionality including its hidden intermediate functions which are automatically executed when objects are being accessed.</abstract>
      <issn>1561-4042</issn>
      <url>http://conceptoriented.com/savinov/publicat/csjm_05.pdf; http://conceptoriented.com/savinov/publicat/csjm_05.ps</url>
    </article>
  </entry>
  <entry id="sabel:03:nondetioinghc">
    <techreport>
      <author>Sabel, David</author>
      <title>Realising nondeterministic I/O in the Glasgow Haskell Compiler</title>
      <institution>Institut für Informatik, J.W. Goethe-Universität Frankfurt am Main</institution>
      <year>2003</year>
      <type>Frank report</type>
      <number>17</number>
      <month>December</month>
      <ps>http://www.ki.informatik.uni-frankfurt.de/papers/sabel/nondetIOinGHC.ps</ps>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/sabel/nondetIOinGHC.pdf</pdf>
      <psgz>http://www.ki.informatik.uni-frankfurt.de/papers/sabel/nondetIOinGHC.ps.gz</psgz>
    </techreport>
  </entry>
  <entry id="schmidt-schauss-schuetz-sabel:04">
    <techreport>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <author>Schütz, Marko</author>
      <author>Sabel, David</author>
      <title>On the Safety of Nöcker's Strictness Analysis</title>
      <institution>Institut für Informatik, J.W. Goethe-Universität Frankfurt am Main</institution>
      <type>Frank Report</type>
      <number>19</number>
      <month>October</month>
      <year>2004</year>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/schauss/unioncalc.pdf</pdf>
    </techreport>
  </entry>
  <entry id="schmidt-schauss-schuetz-sabel:05">
    <techreport>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <author>Schütz, Marko</author>
      <author>Sabel, David</author>
      <title>A Complete Proof of the Safety of Nöcker's Strictness Analysis</title>
      <institution>Institut für Informatik. J.W.Goethe-Universität Frankfurt am Main</institution>
      <type>Frank report</type>
      <number>20</number>
      <year>2005</year>
      <month>April</month>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/schauss/frank20.pdf</pdf>
    </techreport>
  </entry>
  <entry id="schmidt-schauss-sabel-schuetz:05-sc">
    <techreport>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <author>Sabel, David</author>
      <author>Schütz, Marko</author>
      <title>Deciding subset relationship of co-inductively defined set constants</title>
      <institution>Institut für Informatik. Fachbereich Informatik und Mathematik. J. W. Goethe-Universität Frankfurt am Main</institution>
      <type>Frank report</type>
      <number>23</number>
      <year>2006</year>
      <month>September</month>
      <day>28</day>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/schauss/frank-23_v2.pdf</pdf>
      <previousvers>http://www.ki.informatik.uni-frankfurt.de/papers/schauss/frank-23.pdf</previousvers>
    </techreport>
  </entry>
  <entry id="sabel-schmidt-schauss:06-frank-amb">
    <techreport>
      <author>Sabel, David</author>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <title>A Call-by-Need Lambda-Calculus with Locally Bottom-Avoiding Choice: Context Lemma and Correctness of Transformations</title>
      <institution>Institut für Informatik. Fachbereich Informatik und Mathematik. J. W. Goethe-Universität Frankfurt am Main</institution>
      <type>Frank report</type>
      <number>24</number>
      <year>2006</year>
      <month>July</month>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/sabel/frank-24-ambcalcV2.pdf</pdf>
      <previousvers>http://www.ki.informatik.uni-frankfurt.de/papers/sabel/frank-24-ambcalc.pdf</previousvers>
    </techreport>
  </entry>
  <entry id="niehren-sabel-schmidt-schauss-schwinghammer:06">
    <techreport>
      <author>Niehren, Joachim</author>
      <author>Sabel, David</author>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <author>Schwinghammer, Jan</author>
      <title>Program Equivalence for a Concurrent Lambda Calculus with Futures</title>
      <institution>Institut für Informatik. Fachbereich Informatik und Mathematik. J. W. Goethe-Universität Frankfurt am Main</institution>
      <type>Frank report</type>
      <number>26</number>
      <year>2006</year>
      <month>October</month>
      <day>14</day>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/frank/frank-26.pdf</pdf>
    </techreport>
  </entry>
  <entry id="schmidt-schauss-sabel:07">
    <techreport>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <author>Sabel, David</author>
      <title>On Generic Context Lemmas for Lambda Calculi with Sharing</title>
      <institution>Institut für Informatik. Fachbereich Informatik und Mathematik. J. W. Goethe-Universität Frankfurt am Main</institution>
      <type>Frank report</type>
      <number>27</number>
      <year>2007</year>
      <month>January</month>
      <day>6</day>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/frank/frank-27.pdf</pdf>
    </techreport>
  </entry>
  <entry id="schmidt-schauss-sabel-hfl-ib30:07">
    <techreport>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <author>Sabel, David</author>
      <title>Program Transformation for Functional Circuit Descriptions</title>
      <institution>Institut für Informatik. Fachbereich Informatik und Mathematik. J. W. Goethe-Universität Frankfurt am Main</institution>
      <type>Frank report</type>
      <number>30</number>
      <month>February</month>
      <year>2007</year>
      <day>15</day>
      <pdf>http://www.ki.informatik.uni-frankfurt.de/papers/frank/frank-30.pdf</pdf>
    </techreport>
  </entry>
  <entry id="niehren-sabel-schmidt-schauss-schwinghammer:07:entcs">
    <article>
      <author>Niehren, Joachim</author>
      <author>Sabel, David</author>
      <author>Schmidt-Schau{\ss}, Manfred</author>
      <author>Schwinghammer, Jan</author>
      <title>Observational Semantics for a Concurrent Lambda Calculus with Reference Cells and Futures</title>
      <booktitle>Proceedings of the 23rd Conference on the Mathematical Foundations of Programming Semantics (MFPS XXIII)</booktitle>
      <journal>Electronic Notes in Theoretical Computer Science</journal>
      <year>2007</year>
      <volume>173</volume>
      <pages>313-337</pages>
      <month>April</month>
      <publisher>Elsevier</publisher>
      <url>http://www.sciencedirect.com/science/article/B75H1-4N7RX2P-N/2/cdca338e6a140bec05a949ad6b3e98d6</url>
      <doi>doi:10.1016/j.entcs.2007.02.041</doi>
      <copyright>\copyright \href{http://www.elsevier.com/locate/entcs}{Elsevier B.V.}</copyright>
    </article>
  </entry>
  <entry id="giesl-kuehnemann-voigtlaender:2007">
    <article>
      <author>Giesl, Jürgen</author>
      <author>Kühnemann, Armin</author>
      <author>Voigtländer, Janis</author>
      <title>Deaccumulation Techniques for Improving Provability</title>
      <journal>Journal of Logic and Algebraic Programming</journal>
      <volume>71</volume>
      <number>2</number>
      <pages>79-113</pages>
      <year>2007</year>
      <month>APR</month>
      <publisher>Elsevier</publisher>
      <abstract>Several induction theorem provers were developed to verify functional programs mechanically. Unfortunately, automatic verification often fails for functions with accumulating arguments. Using concepts from the theory of tree transducers and extending on earlier work, the paper develops automatic transformations from accumulative functional programs into non-accumulative ones, which are much better suited for mechanized verification. The overall goal is to reduce the need for generalizing induction hypotheses in (semi-)automatic provers. Via the correspondence between imperative programs and tail-recursive functions, the presented approach can also help to reduce the need for inventing loop invariants in the verification of imperative programs.</abstract>
      <keywords>Tree transducers</keywords>
      <keywords>Induction theorem proving</keywords>
      <keywords>Tail recursion</keywords>
      <keywords>Program transformation</keywords>
      <keywords>Program verification</keywords>
      <url>http://wwwtcs.inf.tu-dresden.de/ voigt/Deaccumulation.pdf</url>
    </article>
  </entry>
  <entry id="savinov:2007:apb">
    <techreport>
      <author>Savinov, Alexandr</author>
      <title>An Approach to Programming Based on Concepts</title>
      <institution>Institute of Mathematics and Computer Science, Academy of Sciences of Moldova</institution>
      <type>Technical Report RT0005</type>
      <pages>49</pages>
      <year>2007</year>
      <language>en</language>
      <keywords>concept-oriented programming</keywords>
      <keywords>concept inclusion</keywords>
      <keywords>representation and access</keywords>
      <keywords>indirection</keywords>
      <keywords>aspect-oriented programming</keywords>
      <keywords>object-oriented programming</keywords>
      <keywords>mixins</keywords>
      <abstract>In this paper we describe a new approach to programming which generalizes object-oriented programming. It is based on using a new programming construct, called concept, which generalizes classes. Concept is defined as a pair of two classes: one reference class and one object class. Each concept has a parent concept which is specified using inclusion relation generalizing inheritance. We describe several important mechanisms such as reference resolution, context stack, dual methods and life-cycle management, inheritance and polymorphism. This approach to programming is positioned as a new programming paradigm and therefore we formulate its main principles and rules.</abstract>
      <rights>unrestricted</rights>
      <url>http://conceptoriented.com/savinov/publicat/imi-report_07_2.pdf</url>
    </techreport>
  </entry>
  <entry id="venturini07softpipe">
    <inproceedings>
      <title>Non-Transparent Debugging For Software-Pipelined Loops</title>
      <author>Venturini, Hugo</author>
      <author>Riss, Frederic</author>
      <author>Fernandez, Jean-Claude</author>
      <author>Santana, Miguel</author>
      <booktitle>CASES '07: Proceedings of the 7th International Conference on Compilers, Architecture, and Synthesis for Embedded Systems</booktitle>
      <location>Salzburg, Austria</location>
      <year>2007</year>
      <month>October</month>
    </inproceedings>
  </entry>
  <entry id="wittgenstein74grammar">
    <book>
      <author>Wittgenstein, Ludwig</author>
      <title>Philosophical Grammar</title>
      <publisher>Blackwell</publisher>
      <address>Oxford</address>
      <year>1974</year>
    </book>
  </entry>
  <entry id="vj07">
    <article>
      <author>Voigtländer, Janis</author>
      <author>Johann, Patricia</author>
      <title>Selective strictness and parametricity in structural operational semantics, inequationally</title>
      <journal>Theoretical Computer Science</journal>
      <publisher>Elsevier</publisher>
      <volume>388</volume>
      <number>1-3</number>
      <pages>290-318</pages>
      <year>2007</year>
      <abstract>\emph{Parametric polymorphism} constrains the behavior of pure functional programs in a way that allows the derivation of interesting theorems about them solely from their types, i.e., virtually for free. The formal background of such `free theorems' is well developed for extensions of the Girard-Reynolds polymorphic lambda calculus by \emph{algebraic datatypes} and \emph{general recursion}, provided the resulting calculus is endowed with either a purely strict or a purely nonstrict semantics. But modern functional languages like Clean and Haskell, while using nonstrict evaluation by default, also provide means to enforce strict evaluation of subcomputations at will. The resulting \emph{selective strictness} gives the advanced programmer explicit control over evaluation order, but is not without semantic consequences: it breaks standard parametricity results. This paper develops an operational semantics for a core calculus supporting all the language features emphasized above. Its main achievement is the characterization of observational approximation with respect to this operational semantics via a carefully constructed logical relation. This establishes the formal basis for new parametricity results, as illustrated by several example applications, including the first complete correctness proof for short cut fusion in the presence of selective strictness. The focus on observational approximation, rather than equivalence, allows a finer-grained analysis of computational behavior in the presence of selective strictness than would be possible with observational equivalence alone.</abstract>
      <keywords>Clean</keywords>
      <keywords>Haskell</keywords>
      <keywords>extensionality principles</keywords>
      <keywords>fixpoint recursion</keywords>
      <keywords>functional programming languages</keywords>
      <keywords>identity extension</keywords>
      <keywords>lambda calculus</keywords>
      <keywords>logical relations</keywords>
      <keywords>mixing strict and nonstrict semantics</keywords>
      <keywords>parametric polymorphism</keywords>
      <keywords>program transformations</keywords>
      <keywords>$\hseq$</keywords>
      <keywords>short cut fusion</keywords>
      <keywords>theorems for free</keywords>
      <keywords>types</keywords>
    </article>
  </entry>
  <entry id="voi07">
    <article>
      <author>Voigtländer, Janis</author>
      <title>Formal Efficiency Analysis for Tree Transducer Composition</title>
      <journal>Theory of Computing Systems</journal>
      <publisher>Springer-Verlag</publisher>
      <abstract>We study the question of efficiency improvement or deterioration for a semantics-preserving program transformation technique for (lazy) functional languages, based on composition of restricted macro tree transducers. By annotating programs to reflect the intensional property ``computation time'' explicitly in the computed output and by manipulating such annotations, we formally prove syntactic conditions under which the composed program is guaranteed to be not less efficient than the original program with respect to the number of call-by-need reduction steps required to reach normal form. The criteria developed can be checked automatically and efficiently, and thus are suitable for integration into an optimizing compiler.</abstract>
      <volume>41</volume>
      <number>4</number>
      <pages>619-689</pages>
      <year>2007</year>
    </article>
  </entry>
  <entry id="voi08a">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Proving Correctness via Free Theorems: The Case of the destroy/build-Rule</title>
      <editor>Glück, Robert</editor>
      <editor>de Moor, Oege</editor>
      <booktitle>Symposium on Partial Evaluation and Semantics-Based Program Manipulation, San Francisco, California, Proceedings</booktitle>
      <pages>13-20</pages>
      <month>JAN</month>
      <year>2008</year>
      <publisher>ACM Press</publisher>
      <abstract>Free theorems feature prominently in the field of program transformation for pure functional languages such as Haskell. However, somewhat disappointingly, the semantic properties of so based transformations are often established only very superficially. This paper is intended as a case study showing how to use the existing theoretical foundations and formal methods for improving the situation. To that end, we investigate the correctness issue for a new transformation rule in the short cut fusion family. This destroy/build-rule provides a certain reconciliation between the competing foldr/build- and destroy/unfoldr-approaches to eliminating intermediate lists. Our emphasis is on systematically and rigorously developing the rule's correctness proof, even while paying attention to semantic aspects like potential nontermination and mixed strict/nonstrict evaluation.</abstract>
      <keywords>correctness proofs</keywords>
      <keywords>intermediate data structures</keywords>
      <keywords>program transformations</keywords>
      <keywords>rank-2 types</keywords>
      <keywords>relational parametricity</keywords>
      <keywords>shortcut deforestation</keywords>
      <keywords>theorems for free</keywords>
      <url>http://wwwtcs.inf.tu-dresden.de/ voigt/pepm09-voigtlaender.pdf</url>
    </inproceedings>
  </entry>
  <entry id="voi08b">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Much Ado about Two: A Pearl on Parallel Prefix Computation</title>
      <editor>Wadler, Philip</editor>
      <booktitle>35th Symposium on Principles of Programming Languages, San Francisco, California, Proceedings</booktitle>
      <series>SIGPLAN Notices</series>
      <volume>43</volume>
      <number>1</number>
      <pages>29-35</pages>
      <month>JAN</month>
      <year>2008</year>
      <publisher>ACM Press</publisher>
      <abstract>This pearl develops a statement about parallel prefix computation in the spirit of Knuth's 0-1-Principle for oblivious sorting algorithms. It turns out that 0-1 is not quite enough here. The perfect hammer for the nails we are going to drive in is relational parametricity.</abstract>
      <keywords>0-1-principle</keywords>
      <keywords>free theorems</keywords>
      <keywords>parallel prefix computation</keywords>
      <keywords>relational parametricity</keywords>
      <url>http://wwwtcs.inf.tu-dresden.de/ voigt/popl202-voigtlaender.pdf</url>
    </inproceedings>
  </entry>
  <entry id="voi08c">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Semantics and Pragmatics of New Shortcut Fusion Rules</title>
      <editor>Garrigue, Jacques</editor>
      <editor>Hermenegildo, Manuel</editor>
      <booktitle>9th International Symposium on Functional and Logic Programming, Ise, Japan, Proceedings</booktitle>
      <month>APR</month>
      <year>2008</year>
      <pages>163-179</pages>
      <series>LNCS</series>
      <volume>4989</volume>
      <publisher>Springer-Verlag</publisher>
      <abstract>We study various shortcut fusion rules for languages like Haskell. Following a careful semantic account of a recently proposed rule for circular program transformation, we propose a new rule that trades circularity for higher-orderedness, and thus attains better semantic properties. This also leads us to revisit the original foldr/build-rule, as well as its dual, and to develop variants that do not suffer from detrimental impacts of Haskell's mixed strict/nonstrict semantics. Throughout, we offer pragmatic insights about our new rules to investigate also their relative effectiveness, rather than just their semantic correctness.</abstract>
      <url>http://wwwtcs.inf.tu-dresden.de/ voigt/flops.pdf</url>
    </inproceedings>
  </entry>
  <entry id="voi08d">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Asymptotic Improvement of Computations over Free Monads</title>
      <editor>Paulin-Mohring, Christine</editor>
      <editor>Audebaud, Philippe</editor>
      <booktitle>Mathematics of Program Construction, Marseille, France, Proceedings</booktitle>
      <month>JUL</month>
      <year>2008</year>
      <pages>388-403</pages>
      <series>LNCS</series>
      <volume>5133</volume>
      <publisher>Springer-Verlag</publisher>
      <abstract>We present a low-effort program transformation to improve the efficiency of computations over free monads in Haskell. The development is calculational and carried out in a generic setting, thus applying to a variety of datatypes. An important aspect of our approach is the utilisation of type class mechanisms to make the transformation as transparent as possible, requiring no restructuring of code at all. There is also no extra support necessary from the compiler (apart from an up-to-date type checker). Despite this simplicity of use, our technique is able to achieve true asymptotic runtime improvements. We demonstrate this by examples for which the complexity is reduced from quadratic to linear.</abstract>
      <url>http://wwwtcs.inf.tu-dresden.de/ voigt/mpc08.pdf</url>
    </inproceedings>
  </entry>
  <entry id="programmingbricks">
    <mastersthesis>
      <author>McNerney, Timothy Scott</author>
      <title>Tangible Programming Bricks: An approach to making programming accesible to everyone</title>
      <school>MIT</school>
      <year>2000</year>
      <month>February</month>
      <timestamp>2008.07.07</timestamp>
    </mastersthesis>
  </entry>
  <entry id="stud-2175">
    <mastersthesis>
      <author>Bischof, Marc</author>
      <title>Translating WS-BPEL 2.0 to BPELscript and Vice Versa</title>
      <type>Studienarbeit</type>
      <school>Universität Stuttgart, IAAS</school>
      <year>2008</year>
      <url>http://www.informatik.uni-stuttgart.de/cgi-bin/NCSTRL/NCSTRL_view.pl?id=STUD-2175&amp;engl=</url>
    </mastersthesis>
  </entry>
  <entry id="sem-2008-02">
    <misc>
      <author>Reimann, Steffen</author>
      <title>{Sicherheitslücken durch statische Analyse aufdecken}</title>
      <pages>9</pages>
      <type>Seminararbeit</type>
      <number>Seminararbeit</number>
      <month>April</month>
      <year>2008</year>
      <keywords>Sicherheitslücken</keywords>
      <keywords>Statische Analyse</keywords>
      <keywords>SQL-Injection</keywords>
      <keywords>Cross-Site-Scripting</keywords>
      <keywords>Formatstring</keywords>
      <language>deutsch</language>
      <cr-category>F.3.2 Semantics of Programming Languages</cr-category>
      <ee>ftp://ftp.informatik.uni-stuttgart.de/pub/library/medoc.ustuttgart_fi/SEM-2008-02/SEM-2008-02.pdf, ftp://ftp.informatik.uni-stuttgart.de/pub/library/medoc.ustuttgart_fi/SEM-2008-02/SEM-2008-02.ps</ee>
      <contact>Senden Sie eine E-Mail an seminar@steffen-reimann.de</contact>
      <howpublished>Seminararbeit: Universität Stuttgart, Institut für Softwaretechnologie, Programmiersprachen und Übersetzerbau</howpublished>
      <abstract>Dieses Paper stellt mehrere Verfahren zur Verwendung statischer Analysen bei der Suche nach Sicherheitslücken und Angriffsmöglichkeiten, wie SQL Injections, Cross-Site Scripting und Formatstring Verwundbarkeit, vor. Dabei wird, neben den theoretischen Grundlagen und Prinzipien der Verfahren, auch auf den praktischen Nutzen dieser eingegangen. Zudem werden Fragen nach algorithmischen Beschränkungen der Verfahren sowie ihrer Skalierbarkeit erörtert</abstract>
      <url>http://www.informatik.uni-stuttgart.de/cgi-bin/NCSTRL/NCSTRL_view.pl?id=SEM-2008-02&amp;engl=</url>
    </misc>
  </entry>
  <entry id="inproc-2009-49">
    <inproceedings>
      <author>Bischof, Marc</author>
      <author>Kopp, Oliver</author>
      <author>van Lessen, Tammo</author>
      <author>Leymann, Frank</author>
      <title>{BPELscript: A Simplified Script Syntax for WS-BPEL 2.0}</title>
      <booktitle>2009 35th Euromicro Conference on Software Engineering and Advanced Applications (SEAA 2009)</booktitle>
      <publisher>IEEE Computer Society Press</publisher>
      <institution>Universität Stuttgart, Fakultät Informatik, Elektrotechnik und Informationstechnik, Germany</institution>
      <type>Konferenz-Beitrag</type>
      <month>August</month>
      <year>2009</year>
      <keywords>service orchestration</keywords>
      <keywords>service scripting</keywords>
      <keywords>BPEL</keywords>
      <keywords>BPM lifecycle</keywords>
      <language>Englisch</language>
      <cr-category>D.1.1 (Applicative Functional) Programming, D.3.4 Programming Languages Processors, H.4.1 Office Automation, K.1 The Computer Industry</cr-category>
      <department>Universität Stuttgart, Institut für Architektur von Anwendungssystemen</department>
      <abstract>Business processes are usually modeled using graphical notations such as BPMN. As a first step towards execution as workflow, a business process is transformed to an abstract WS-BPEL process. Technical details required for execution are added by an IT expert. While IT experts expect Java-like syntax for programs, WS-BPEL requires processes to be expressed in XML. This paper introduces BPELscript as a new syntax for WS-BPEL aiming to reduce the barrier for IT experts to use WS-BPEL by providing a JavaScript-inspired syntax.</abstract>
      <url>http://www.informatik.uni-stuttgart.de/cgi-bin/NCSTRL/NCSTRL_view.pl?id=INPROC-2009-49&amp;engl=0</url>
    </inproceedings>
  </entry>
  <entry id="sv09a">
    <inproceedings>
      <author>Stenger, Florian</author>
      <author>Voigtländer, Janis</author>
      <title>Parametricity for Haskell with Imprecise Error Semantics</title>
      <editor>Curien, Pierre-Louis</editor>
      <booktitle>Typed Lambda Calculi and Applications, Brasilia, Brazil, Proceedings</booktitle>
      <month>JUL</month>
      <year>2009</year>
      <pages>294-308</pages>
      <series>LNCS</series>
      <volume>5608</volume>
      <publisher>Springer-Verlag</publisher>
      <abstract>Error raising, propagation, and handling in Haskell can be imprecise in the sense that a language implementation's choice of local evaluation order, and optimizing transformations to apply, may influence which of a number of potential failure events hidden somewhere in a program is actually triggered. While this has pragmatic advantages from an implementation point of view, it also complicates the meaning of programs and thus requires extra care when reasoning about them. The proper semantic setup is one in which every erroneous value represents a whole set of potential (but not arbitrary) failure causes. The associated propagation rules are somewhat askew to standard notions of program flow and value dependence. As a consequence, standard reasoning techniques are cast into doubt, and rightly so. We study this issue in depth for one such reasoning technique, namely the derivation of free theorems from polymorphic types. We revise and extend the foundational notion of relational parametricity, as well as further material required to make it applicable.</abstract>
    </inproceedings>
  </entry>
  <entry id="voi09">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Bidirectionalization for Free!</title>
      <editor>Pierce, Benjamin C.\</editor>
      <booktitle>36th Symposium on Principles of Programming Languages, Savannah, Georgia, Proceedings</booktitle>
      <pages>165-176</pages>
      <month>JAN</month>
      <year>2009</year>
      <publisher>ACM Press</publisher>
      <abstract>A bidirectional transformation consists of a function get that takes a source (document or value) to a view and a function put that takes an updated view and the original source back to an updated source, governed by certain consistency conditions relating the two functions. Both the database and programming language communities have studied techniques that essentially allow a user to specify only one of get and put and have the other inferred automatically. All approaches so far to this bidirectionalization task have been syntactic in nature, either proposing a domain-specific language with limited expressiveness but built-in (and composable) backward components, or restricting get to a simple syntactic form from which some algorithm can synthesize an appropriate definition for put. Here we present a semantic approach instead . The idea is to take a general-purpose language, Haskell, and write a higher-order function that takes (polymorphic) get-functions as arguments and returns appropriate put-functions. All this on the level of semantic values, without being willing, or even able, to inspect the definition of get, and thus liberated from syntactic restraints. Our solution is inspired by relational parametricity and uses free theorems for proving the consistency conditions. It works beautifully.</abstract>
      <keywords>bidirectionalization</keywords>
      <keywords>free theorems</keywords>
      <keywords>generic programming</keywords>
      <keywords>Haskell</keywords>
      <keywords>program transformation</keywords>
      <keywords>relational parametricity</keywords>
      <keywords>view-update problem</keywords>
    </inproceedings>
  </entry>
  <entry id="reynolds96">
    <techreport>
      <author>Reynolds, John C.</author>
      <title>Design of the Programming Language Forsythe</title>
      <type>Report</type>
      <number>CMU-CS-96-146</number>
      <institution>Carnegie Mellon University</institution>
      <department>School of Computer Science</department>
      <address>Pittsburgh, Pennsylvania</address>
      <month>June 28,</month>
      <year>1996</year>
      <reprint>Reprinted in \authorcite{O'Hearn and Tennent} \crosscite[vol. 1, page s 173-233]{OHEARN97}</reprint>
      <comments>supersedes REYNOLDS88B</comments>
      <filename>forsytherep</filename>
      <abstract>This is a description of the programming language Forsythe, which is a descendant of Algol 60 intended to be as uniform and general as possible, while retaining the basic character of its progenitor.</abstract>
      <checked>28 June 1996</checked>
      <updated>10 May 1997</updated>
    </techreport>
  </entry>
  <entry id="voi09b">
    <inproceedings>
      <author>Voigtländer, Janis</author>
      <title>Free Theorems Involving Type Constructor Classes</title>
      <editor>Tolmach, Andrew</editor>
      <booktitle>14th International Conference on Functional Programming, Edinburgh, Scotland, Proceedings</booktitle>
      <series>SIGPLAN Notices</series>
      <volume>44</volume>
      <number>9</number>
      <pages>173-184</pages>
      <month>SEP</month>
      <year>2009</year>
      <publisher>ACM Press</publisher>
      <abstract>Free theorems are a charm, allowing the derivation of useful statements about programs from their (polymorphic) types alone. We show how to reap such theorems not only from polymorphism over ordinary types, but also from polymorphism over type constructors restricted by class constraints. Our prime application area is that of monads, which form the probably most popular type constructor class of Haskell. To demonstrate the broader scope, we also deal with a transparent way of introducing difference lists into a program, endowed with a neat and general correctness proof.</abstract>
      <keywords>relational parametricity</keywords>
      <doi>10.1145/1596550.1596577</doi>
    </inproceedings>
  </entry>
  <entry id="sv09b">
    <inproceedings>
      <author>Seidel, Daniel</author>
      <author>Voigtländer, Janis</author>
      <title>Taming Selective Strictness</title>
      <booktitle>Arbeitstagung Programmiersprachen, Lübeck, Germany, Proceedings</booktitle>
      <month>OCT</month>
      <year>2009</year>
      <pages>2916-2930</pages>
      <series>Lecture Notes in Informatics</series>
      <volume>154</volume>
      <publisher>GI</publisher>
      <abstract>Free theorems establish interesting properties of parametrically polymorphic functions, solely from their types, and serve as a nice proof tool. For pure and lazy functional programming languages, they can be used with very few preconditions. Unfortunately, in the presence of selective strictness, as provided in languages like Haskell, their original strength is reduced. In this paper we present an approach for restrengthening them. By a refined type system which tracks the use of strict evaluation, we rule out unnecessary restrictions that otherwise emerge from the general suspicion that strict evaluation may be used at any point. Additionally, we provide an implemented algorithm determining all refined types for a given term.</abstract>
    </inproceedings>
  </entry>
  <entry id="csv10">
    <inproceedings>
      <author>Christiansen, Jan</author>
      <author>Seidel, Daniel</author>
      <author>Voigtländer, Janis</author>
      <title>Free Theorems for Functional Logic Programs</title>
      <editor>Filliâtre, Jean-Christophe</editor>
      <editor>Flanagan, Cormac</editor>
      <booktitle>4th Workshop on Programming Languages meets Program Verification, Madrid, Spain, Proceedings</booktitle>
      <pages>39-48</pages>
      <month>JAN</month>
      <year>2010</year>
      <publisher>ACM Press</publisher>
      <abstract>Type-based reasoning is popular in functional programming. In particular, parametric polymorphism constrains functions in such a way that statements about their behavior can be derived without consulting function definitions. Is the same possible in a strongly, and polymorphically, typed functional logic language? This is the question we study in this paper. Logical features like nondeterminism and free variables cause interesting effects, which we examine based on examples and address by identifying appropriate conditions that guarantee standard free theorems or inequational versions thereof to hold. We see this case study as a stepping stone for a general theory, not provided here, involving the definition of a logical relation and other machinery required for parametricity arguments appropriate to functional logic languages.</abstract>
      <keywords>relational parametricity</keywords>
      <keywords>Curry</keywords>
      <keywords>Haskell</keywords>
      <doi>10.1145/1707790.1707797</doi>
    </inproceedings>
  </entry>
  <entry id="dietrich00">
    <incollection>
      <author>Dietrich, J. W.</author>
      <author>Fischer, M. R.</author>
      <editor>Koop, A.</editor>
      <editor>Novak, D. C.</editor>
      <title>{FORMOSA} - Ein interaktives {XML}-Derivat für die klinische Mathematik</title>
      <booktitle>Computerunterstützte Ausbildung in der Medizin</booktitle>
      <pages>36-43</pages>
      <publisher>Shaker</publisher>
      <address>Aachen</address>
      <year>2000</year>
    </incollection>
  </entry>
</file>

